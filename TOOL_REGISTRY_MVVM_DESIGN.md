# Tool Registry Browser - Complete MVVM Architecture Design Document

## Executive Summary

### Project Overview
Complete rebuild of the Tool Registry Browser application using professional MVVM (Model-View-ViewModel) architecture, Umbilical Component Protocol, and responsive design principles. This document serves as the complete technical specification for creating a maintainable, scalable, and fully responsive tool management interface.

### Why Rebuild?
The current implementation suffers from critical architectural issues:
- Hardcoded HTML mixed with component logic
- Inline styles preventing responsive design
- Lack of proper component separation
- No standardized component protocol
- Fixed pixel values preventing fluid responsiveness

### Project Goals
- **Professional Architecture**: Implement strict MVVM separation in all components
- **Zero Hardcoded HTML**: All markup generated dynamically by component View layers
- **CSS Classes Only**: Eliminate all inline styles throughout the system
- **Full Responsiveness**: Fluid design using clamp(), vh, vw, rem (no pixels)
- **Component Protocol**: All components follow Umbilical Protocol standard
- **Maintainable Codebase**: Clear separation of concerns and standardized patterns

## Core Architecture Principles

### 1. MVVM Architecture Requirements
Every component must implement strict Model-View-ViewModel separation:

```javascript
// Required pattern for all components
export const ComponentName = {
  create(umbilical) {
    // Umbilical protocol compliance
    if (umbilical.describe) { /* introspection */ }
    if (umbilical.validate) { /* validation */ }
    
    // MVVM layers
    const model = new ComponentModel();
    const view = new ComponentView(umbilical.dom);
    const viewModel = new ComponentViewModel(model, view);
    
    return viewModel.initialize();
  }
};
```

### 2. Zero Hardcoded HTML Rule
**FORBIDDEN**: Any HTML in main application files
```javascript
// ❌ NEVER DO THIS
app.innerHTML = `<div class="header">...</div>`;
```

**REQUIRED**: All HTML generated by component View layers
```javascript
// ✅ CORRECT APPROACH
class ComponentView {
  render(modelData) {
    const element = document.createElement('div');
    element.className = 'component-container';
    return this.buildStructure(element, modelData);
  }
}
```

### 3. CSS Classes Only Rule
**FORBIDDEN**: Any inline styles anywhere
```javascript
// ❌ NEVER DO THIS
element.style.padding = '20px';
element.setAttribute('style', 'color: red;');
```

**REQUIRED**: CSS classes with responsive design
```javascript
// ✅ CORRECT APPROACH
element.className = 'responsive-container';
// With CSS: .responsive-container { padding: clamp(1rem, 3vw, 2rem); }
```

### 4. Responsive Design Philosophy
**Core Principle**: Everything scales fluidly without media queries
- **Typography**: `font-size: clamp(0.875rem, 2.5vw, 1.125rem)`
- **Spacing**: `padding: clamp(1rem, 3vh, 2rem) clamp(1rem, 4vw, 3rem)`
- **Layout**: Flexbox and CSS Grid with fractional units
- **Components**: Scale proportionally to viewport

### 5. Umbilical Protocol Compliance
All components must support three operational modes:
```javascript
// 1. Introspection Mode
Component.create({ describe: (requirements) => {...} });

// 2. Validation Mode  
Component.create({ validate: (testUmbilical) => {...} });

// 3. Instance Mode
Component.create({ dom: element, ...capabilities });
```

## Component Architecture Specifications

### System Component Hierarchy
```
ToolRegistryBrowser (Root Application)
├── ApplicationHeader
│   ├── AppTitle
│   ├── AppDescription  
│   └── GlobalSearch (future)
├── NavigationTabs
│   ├── TabButton (multiple)
│   └── TabContentArea
└── PanelRenderer
    ├── ToolSearchPanel
    │   ├── SearchControls
    │   ├── FilterControls
    │   └── ResultsGrid
    ├── ModuleBrowserPanel
    │   ├── ModuleTree
    │   ├── ModuleDetails
    │   └── ToolsList
    ├── ToolDetailsPanel
    │   ├── ToolOverview
    │   ├── SchemaVisualization
    │   └── Documentation
    └── AdministrationPanel
        ├── UserManagement
        ├── SystemSettings
        └── DataImport
```

## Detailed Component Specifications

### 1. ToolRegistryBrowser (Root Component)

#### Purpose
Main application container that coordinates all child components and manages global application state.

#### File Structure
```
/src/components/tool-registry/
├── index.js                    # Main component export
├── model/
│   └── ToolRegistryModel.js   # Application state management
├── view/
│   └── ToolRegistryView.js    # DOM structure and CSS classes
└── viewmodel/
    └── ToolRegistryViewModel.js # Coordination logic
```

#### Model Layer
```javascript
// /src/components/tool-registry/model/ToolRegistryModel.js
export class ToolRegistryModel {
  constructor() {
    this.state = {
      // Application State
      currentPanel: 'search',
      isLoading: false,
      errorState: null,
      connectionStatus: 'disconnected',
      
      // Data State
      tools: new Map(),
      modules: new Map(), 
      searchResults: [],
      selectedTool: null,
      selectedModule: null,
      
      // UI State
      windowDimensions: { width: 0, height: 0 },
      activeFilters: {},
      userPreferences: {
        theme: 'light',
        defaultView: 'search',
        itemsPerPage: 20
      }
    };
    
    // Event system for component communication
    this.eventEmitter = new EventTarget();
    this.subscriptions = new Map();
  }
  
  // State management methods
  updateState(path, value) {
    const oldValue = this.getState(path);
    this.setNestedProperty(this.state, path, value);
    this.emit('stateChanged', { path, value, oldValue });
  }
  
  getState(path) {
    return this.getNestedProperty(this.state, path);
  }
  
  subscribe(path, callback) {
    if (!this.subscriptions.has(path)) {
      this.subscriptions.set(path, new Set());
    }
    this.subscriptions.get(path).add(callback);
    
    return () => this.subscriptions.get(path)?.delete(callback);
  }
  
  emit(eventType, data) {
    this.eventEmitter.dispatchEvent(new CustomEvent(eventType, { detail: data }));
  }
}
```

#### View Layer
```javascript
// /src/components/tool-registry/view/ToolRegistryView.js
export class ToolRegistryView {
  constructor(container) {
    this.container = container;
    this.cssInjected = false;
    this.elements = new Map();
  }
  
  generateCSS() {
    return `
      /* CSS Variables for Responsive Design */
      :root {
        /* Spacing System */
        --spacing-xs: clamp(0.25rem, 1vw, 0.5rem);
        --spacing-sm: clamp(0.5rem, 2vw, 1rem);
        --spacing-md: clamp(1rem, 3vw, 2rem);
        --spacing-lg: clamp(2rem, 5vw, 4rem);
        --spacing-xl: clamp(3rem, 8vw, 6rem);
        
        /* Typography System */
        --font-xs: clamp(0.75rem, 2vw, 0.875rem);
        --font-sm: clamp(0.875rem, 2.5vw, 1rem);
        --font-md: clamp(1rem, 3vw, 1.25rem);
        --font-lg: clamp(1.25rem, 4vw, 2rem);
        --font-xl: clamp(2rem, 6vw, 3rem);
        --font-xxl: clamp(2.5rem, 8vw, 4rem);
        
        /* Color System */
        --color-primary: #3b82f6;
        --color-primary-hover: #2563eb;
        --color-secondary: #64748b;
        --color-success: #10b981;
        --color-warning: #f59e0b;
        --color-error: #ef4444;
        
        --surface-primary: #ffffff;
        --surface-secondary: #f8fafc;
        --surface-tertiary: #f1f5f9;
        --surface-hover: #e2e8f0;
        
        --text-primary: #1e293b;
        --text-secondary: #64748b;
        --text-tertiary: #94a3b8;
        
        --border-subtle: #e2e8f0;
        --border-medium: #cbd5e1;
        --border-strong: #94a3b8;
        
        /* Shadows */
        --shadow-sm: 0 0.0625rem 0.125rem rgba(0, 0, 0, 0.1);
        --shadow-md: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.1);
        --shadow-lg: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.15);
        
        /* Border Radius */
        --radius-sm: clamp(0.25rem, 0.5vw, 0.375rem);
        --radius-md: clamp(0.375rem, 1vw, 0.5rem);
        --radius-lg: clamp(0.5rem, 1.5vw, 0.75rem);
      }
      
      /* Root Application Styles */
      .tool-registry-app {
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: column;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: var(--surface-secondary);
        color: var(--text-primary);
        line-height: 1.6;
      }
      
      /* Header Section */
      .app-header {
        flex-shrink: 0;
        background: var(--surface-primary);
        border-bottom: 0.125rem solid var(--border-subtle);
        box-shadow: var(--shadow-sm);
      }
      
      /* Main Content Area */
      .main-content {
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      
      /* Loading States */
      .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      
      .loading-spinner {
        width: clamp(2rem, 5vw, 3rem);
        height: clamp(2rem, 5vw, 3rem);
        border: 0.25rem solid var(--border-subtle);
        border-top: 0.25rem solid var(--color-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      /* Error States */
      .error-container {
        padding: var(--spacing-lg);
        text-align: center;
        color: var(--color-error);
      }
      
      .error-title {
        font-size: var(--font-lg);
        font-weight: 600;
        margin-bottom: var(--spacing-md);
      }
      
      .error-message {
        font-size: var(--font-md);
        margin-bottom: var(--spacing-lg);
      }
      
      /* Utility Classes */
      .visually-hidden {
        position: absolute;
        width: 0.0625rem;
        height: 0.0625rem;
        padding: 0;
        margin: -0.0625rem;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
      
      .scroll-container {
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: var(--border-medium) transparent;
      }
      
      .scroll-container::-webkit-scrollbar {
        width: 0.5rem;
      }
      
      .scroll-container::-webkit-scrollbar-track {
        background: transparent;
      }
      
      .scroll-container::-webkit-scrollbar-thumb {
        background: var(--border-medium);
        border-radius: var(--radius-sm);
      }
      
      .scroll-container::-webkit-scrollbar-thumb:hover {
        background: var(--border-strong);
      }
    `;
  }
  
  injectCSS() {
    if (this.cssInjected) return;
    
    const styleElement = document.createElement('style');
    styleElement.textContent = this.generateCSS();
    document.head.appendChild(styleElement);
    this.cssInjected = true;
  }
  
  render(modelData) {
    this.injectCSS();
    
    // Clear container
    this.container.innerHTML = '';
    this.container.className = 'tool-registry-app';
    
    // Create main structure
    const headerContainer = this.createHeaderContainer();
    const mainContent = this.createMainContent();
    
    this.container.appendChild(headerContainer);
    this.container.appendChild(mainContent);
    
    // Store element references
    this.elements.set('header', headerContainer);
    this.elements.set('main', mainContent);
    
    return this.container;
  }
  
  createHeaderContainer() {
    const header = document.createElement('div');
    header.className = 'app-header';
    header.id = 'app-header-container';
    return header;
  }
  
  createMainContent() {
    const main = document.createElement('div');
    main.className = 'main-content';
    main.id = 'main-content-container';
    return main;
  }
  
  showLoading() {
    const overlay = document.createElement('div');
    overlay.className = 'loading-overlay';
    overlay.innerHTML = '<div class="loading-spinner"></div>';
    this.container.appendChild(overlay);
  }
  
  hideLoading() {
    const overlay = this.container.querySelector('.loading-overlay');
    if (overlay) {
      overlay.remove();
    }
  }
  
  showError(error) {
    const errorContainer = document.createElement('div');
    errorContainer.className = 'error-container';
    errorContainer.innerHTML = `
      <h2 class="error-title">Application Error</h2>
      <p class="error-message">${error.message || 'An unexpected error occurred'}</p>
    `;
    
    const main = this.elements.get('main');
    main.innerHTML = '';
    main.appendChild(errorContainer);
  }
}
```

#### ViewModel Layer
```javascript
// /src/components/tool-registry/viewmodel/ToolRegistryViewModel.js
export class ToolRegistryViewModel {
  constructor(model, view, umbilical) {
    this.model = model;
    this.view = view;
    this.umbilical = umbilical;
    
    // Child components
    this.components = new Map();
    
    // WebSocket connection
    this.websocket = null;
    
    // Cleanup functions
    this.cleanupFunctions = [];
  }
  
  async initialize() {
    try {
      // Show loading state
      this.view.showLoading();
      
      // Render initial structure
      this.view.render(this.model.getState());
      
      // Initialize WebSocket connection
      await this.initializeWebSocket();
      
      // Load child components
      await this.loadChildComponents();
      
      // Set up event listeners
      this.setupEventListeners();
      
      // Load initial data
      await this.loadInitialData();
      
      // Hide loading state
      this.view.hideLoading();
      
      // Notify parent of successful mount
      if (this.umbilical.onMount) {
        this.umbilical.onMount(this.createPublicAPI());
      }
      
      return this.createPublicAPI();
      
    } catch (error) {
      this.view.hideLoading();
      this.view.showError(error);
      console.error('ToolRegistryBrowser initialization failed:', error);
      throw error;
    }
  }
  
  async initializeWebSocket() {
    if (!this.umbilical.websocketUrl) return;
    
    try {
      const { WebSocketManager } = await import('./utils/WebSocketManager.js');
      this.websocket = new WebSocketManager(this.umbilical.websocketUrl);
      
      await this.websocket.connect();
      this.setupWebSocketListeners();
      
      this.model.updateState('connectionStatus', 'connected');
      
    } catch (error) {
      console.warn('WebSocket connection failed:', error);
      this.model.updateState('connectionStatus', 'failed');
    }
  }
  
  setupWebSocketListeners() {
    this.websocket.subscribe('tools.updated', (data) => {
      this.handleToolsUpdate(data);
    });
    
    this.websocket.subscribe('modules.updated', (data) => {
      this.handleModulesUpdate(data);
    });
    
    this.websocket.subscribe('system.status', (data) => {
      this.handleSystemStatus(data);
    });
  }
  
  async loadChildComponents() {
    // Load ApplicationHeader
    const { ApplicationHeader } = await import('./components/ApplicationHeader.js');
    const headerContainer = document.getElementById('app-header-container');
    
    this.components.set('header', ApplicationHeader.create({
      dom: headerContainer,
      title: '🛠️ Legion Tool Registry',
      subtitle: 'Professional tool management and discovery platform',
      onMount: () => console.log('ApplicationHeader mounted')
    }));
    
    // Load NavigationTabs
    const { NavigationTabs } = await import('./components/NavigationTabs.js');
    const mainContainer = document.getElementById('main-content-container');
    
    this.components.set('navigation', NavigationTabs.create({
      dom: mainContainer,
      tabs: [
        { id: 'search', title: '🔍 Tool Search', component: 'ToolSearchPanel' },
        { id: 'modules', title: '📦 Module Browser', component: 'ModuleBrowserPanel' },
        { id: 'details', title: '📋 Tool Details', component: 'ToolDetailsPanel' },
        { id: 'admin', title: '⚙️ Administration', component: 'AdministrationPanel' }
      ],
      activeTab: this.model.getState('currentPanel'),
      onTabChange: (tabId) => this.handleTabChange(tabId),
      onMount: () => console.log('NavigationTabs mounted')
    }));
  }
  
  handleTabChange(tabId) {
    this.model.updateState('currentPanel', tabId);
    
    if (this.umbilical.onTabChange) {
      this.umbilical.onTabChange(tabId, { title: this.getTabTitle(tabId) });
    }
  }
  
  setupEventListeners() {
    // Window resize handling
    const handleResize = () => {
      this.model.updateState('windowDimensions', {
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    this.cleanupFunctions.push(() => window.removeEventListener('resize', handleResize));
    
    // State change listeners
    const unsubscribe = this.model.subscribe('currentPanel', (newPanel) => {
      this.loadPanelComponent(newPanel);
    });
    this.cleanupFunctions.push(unsubscribe);
  }
  
  async loadInitialData() {
    // Load tools and modules data
    if (this.websocket) {
      this.websocket.publish('data.request', {
        type: 'initial_load',
        includes: ['tools', 'modules', 'user_preferences']
      });
    }
  }
  
  createPublicAPI() {
    return {
      // State management
      getState: (path) => this.model.getState(path),
      updateState: (path, value) => this.model.updateState(path, value),
      
      // Navigation
      switchToPanel: (panelId) => this.handleTabChange(panelId),
      getCurrentPanel: () => this.model.getState('currentPanel'),
      
      // Data access
      getTools: () => this.model.getState('tools'),
      getModules: () => this.model.getState('modules'),
      
      // Component access
      getComponent: (name) => this.components.get(name),
      
      // Cleanup
      destroy: () => this.destroy()
    };
  }
  
  destroy() {
    // Run all cleanup functions
    this.cleanupFunctions.forEach(cleanup => cleanup());
    
    // Destroy child components
    this.components.forEach(component => {
      if (component.destroy) {
        component.destroy();
      }
    });
    
    // Close WebSocket connection
    if (this.websocket) {
      this.websocket.disconnect();
    }
    
    // Clear DOM
    this.view.container.innerHTML = '';
    
    // Notify parent of destruction
    if (this.umbilical.onDestroy) {
      this.umbilical.onDestroy();
    }
  }
}
```

#### Main Component Export
```javascript
// /src/components/tool-registry/index.js
import { UmbilicalUtils } from '../../umbilical/index.js';
import { ToolRegistryModel } from './model/ToolRegistryModel.js';
import { ToolRegistryView } from './view/ToolRegistryView.js';
import { ToolRegistryViewModel } from './viewmodel/ToolRegistryViewModel.js';

export const ToolRegistryBrowser = {
  create(umbilical) {
    // 1. Introspection Mode
    if (umbilical.describe) {
      const requirements = UmbilicalUtils.createRequirements();
      requirements.add('dom', 'HTMLElement', 'Container element for the application');
      requirements.add('websocketUrl', 'string', 'WebSocket URL for real-time data (optional)', false);
      requirements.add('onMount', 'function', 'Callback when application is mounted (optional)', false);
      requirements.add('onDestroy', 'function', 'Callback when application is destroyed (optional)', false);
      requirements.add('onTabChange', 'function', 'Callback when navigation tab changes (optional)', false);
      requirements.add('onError', 'function', 'Callback for error handling (optional)', false);
      umbilical.describe(requirements);
      return;
    }
    
    // 2. Validation Mode
    if (umbilical.validate) {
      return umbilical.validate({
        hasDomElement: umbilical.dom && umbilical.dom.nodeType === Node.ELEMENT_NODE,
        hasValidWebSocketUrl: !umbilical.websocketUrl || typeof umbilical.websocketUrl === 'string'
      });
    }
    
    // 3. Instance Creation Mode
    UmbilicalUtils.validateCapabilities(umbilical, ['dom'], 'ToolRegistryBrowser');
    
    // Create MVVM layers
    const model = new ToolRegistryModel();
    const view = new ToolRegistryView(umbilical.dom);
    const viewModel = new ToolRegistryViewModel(model, view, umbilical);
    
    // Initialize and return public API
    return viewModel.initialize();
  }
};
```

### 2. ApplicationHeader Component

#### Purpose
Displays application title, subtitle, and global controls like search and user management.

#### File Structure
```
/src/components/tool-registry/components/
└── ApplicationHeader.js
```

#### Complete Implementation
```javascript
// /src/components/tool-registry/components/ApplicationHeader.js
import { UmbilicalUtils } from '../../../umbilical/index.js';

class ApplicationHeaderModel {
  constructor(options = {}) {
    this.state = {
      title: options.title || 'Application',
      subtitle: options.subtitle || '',
      showSearch: options.showSearch !== false,
      searchQuery: '',
      userInfo: options.userInfo || null
    };
  }
  
  updateState(path, value) {
    const keys = path.split('.');
    let current = this.state;
    for (let i = 0; i < keys.length - 1; i++) {
      current = current[keys[i]];
    }
    current[keys[keys.length - 1]] = value;
  }
  
  getState(path = '') {
    if (!path) return this.state;
    return path.split('.').reduce((obj, key) => obj?.[key], this.state);
  }
}

class ApplicationHeaderView {
  constructor(container) {
    this.container = container;
    this.cssInjected = false;
  }
  
  generateCSS() {
    return `
      .app-header-container {
        padding: var(--spacing-md) var(--spacing-lg);
        background: var(--surface-primary);
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: var(--spacing-md);
        min-height: clamp(4rem, 12vh, 6rem);
      }
      
      .header-main-content {
        flex: 1;
        min-width: clamp(20rem, 40vw, 30rem);
      }
      
      .app-title {
        font-size: var(--font-xl);
        font-weight: 700;
        margin: 0 0 var(--spacing-xs) 0;
        color: var(--text-primary);
        line-height: 1.2;
      }
      
      .app-subtitle {
        font-size: var(--font-md);
        color: var(--text-secondary);
        margin: 0;
        line-height: 1.4;
      }
      
      .header-controls {
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
        flex-shrink: 0;
      }
      
      .global-search-container {
        position: relative;
        min-width: clamp(15rem, 25vw, 20rem);
      }
      
      .global-search-input {
        width: 100%;
        padding: var(--spacing-sm) var(--spacing-md);
        padding-left: clamp(2.5rem, 6vw, 3rem);
        font-size: var(--font-sm);
        border: 0.125rem solid var(--border-subtle);
        border-radius: var(--radius-md);
        background: var(--surface-secondary);
        color: var(--text-primary);
        transition: all 0.2s ease;
      }
      
      .global-search-input:focus {
        outline: none;
        border-color: var(--color-primary);
        box-shadow: 0 0 0 0.1875rem rgba(59, 130, 246, 0.15);
        background: var(--surface-primary);
      }
      
      .global-search-input::placeholder {
        color: var(--text-tertiary);
      }
      
      .search-icon {
        position: absolute;
        left: var(--spacing-sm);
        top: 50%;
        transform: translateY(-50%);
        width: clamp(1rem, 2.5vw, 1.25rem);
        height: clamp(1rem, 2.5vw, 1.25rem);
        color: var(--text-tertiary);
        pointer-events: none;
      }
      
      .user-controls {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
      }
      
      .user-avatar {
        width: clamp(2rem, 5vw, 2.5rem);
        height: clamp(2rem, 5vw, 2.5rem);
        border-radius: 50%;
        background: var(--color-primary);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: var(--font-sm);
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .user-avatar:hover {
        background: var(--color-primary-hover);
        transform: scale(1.05);
      }
      
      .notifications-button {
        padding: var(--spacing-sm);
        background: transparent;
        border: 0.125rem solid var(--border-subtle);
        border-radius: var(--radius-sm);
        cursor: pointer;
        color: var(--text-secondary);
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .notifications-button:hover {
        border-color: var(--color-primary);
        color: var(--color-primary);
        background: rgba(59, 130, 246, 0.05);
      }
      
      @media (max-width: 48rem) {
        .app-header-container {
          flex-direction: column;
          align-items: stretch;
          text-align: center;
        }
        
        .header-controls {
          justify-content: center;
          flex-wrap: wrap;
        }
        
        .global-search-container {
          min-width: 100%;
        }
      }
    `;
  }
  
  injectCSS() {
    if (this.cssInjected) return;
    
    const styleElement = document.createElement('style');
    styleElement.textContent = this.generateCSS();
    document.head.appendChild(styleElement);
    this.cssInjected = true;
  }
  
  render(modelData) {
    this.injectCSS();
    
    this.container.innerHTML = '';
    this.container.className = 'app-header-container';
    
    // Main content (title and subtitle)
    const mainContent = this.createMainContent(modelData);
    this.container.appendChild(mainContent);
    
    // Controls (search and user)
    if (modelData.showSearch || modelData.userInfo) {
      const controls = this.createHeaderControls(modelData);
      this.container.appendChild(controls);
    }
    
    return this.container;
  }
  
  createMainContent(modelData) {
    const mainContent = document.createElement('div');
    mainContent.className = 'header-main-content';
    
    const title = document.createElement('h1');
    title.className = 'app-title';
    title.textContent = modelData.title;
    
    const subtitle = document.createElement('p');
    subtitle.className = 'app-subtitle';
    subtitle.textContent = modelData.subtitle;
    
    mainContent.appendChild(title);
    if (modelData.subtitle) {
      mainContent.appendChild(subtitle);
    }
    
    return mainContent;
  }
  
  createHeaderControls(modelData) {
    const controls = document.createElement('div');
    controls.className = 'header-controls';
    
    // Global search
    if (modelData.showSearch) {
      const searchContainer = this.createSearchControl(modelData);
      controls.appendChild(searchContainer);
    }
    
    // User controls
    if (modelData.userInfo) {
      const userControls = this.createUserControls(modelData);
      controls.appendChild(userControls);
    }
    
    return controls;
  }
  
  createSearchControl(modelData) {
    const container = document.createElement('div');
    container.className = 'global-search-container';
    
    const searchIcon = document.createElement('div');
    searchIcon.className = 'search-icon';
    searchIcon.innerHTML = '🔍';
    
    const input = document.createElement('input');
    input.className = 'global-search-input';
    input.type = 'text';
    input.placeholder = 'Search tools, modules, or documentation...';
    input.value = modelData.searchQuery || '';
    
    container.appendChild(searchIcon);
    container.appendChild(input);
    
    return container;
  }
  
  createUserControls(modelData) {
    const controls = document.createElement('div');
    controls.className = 'user-controls';
    
    // Notifications button
    const notificationsButton = document.createElement('button');
    notificationsButton.className = 'notifications-button';
    notificationsButton.innerHTML = '🔔';
    notificationsButton.title = 'Notifications';
    
    // User avatar
    const avatar = document.createElement('div');
    avatar.className = 'user-avatar';
    avatar.textContent = modelData.userInfo?.initials || '👤';
    avatar.title = modelData.userInfo?.name || 'User Account';
    
    controls.appendChild(notificationsButton);
    controls.appendChild(avatar);
    
    return controls;
  }
}

class ApplicationHeaderViewModel {
  constructor(model, view, umbilical) {
    this.model = model;
    this.view = view;
    this.umbilical = umbilical;
    this.eventListeners = [];
  }
  
  initialize() {
    this.render();
    this.setupEventListeners();
    
    if (this.umbilical.onMount) {
      this.umbilical.onMount(this.createPublicAPI());
    }
    
    return this.createPublicAPI();
  }
  
  render() {
    this.view.render(this.model.getState());
  }
  
  setupEventListeners() {
    const searchInput = this.view.container.querySelector('.global-search-input');
    if (searchInput) {
      const handleSearch = (event) => {
        const query = event.target.value;
        this.model.updateState('searchQuery', query);
        
        if (this.umbilical.onSearch) {
          this.umbilical.onSearch(query);
        }
      };
      
      searchInput.addEventListener('input', handleSearch);
      this.eventListeners.push(() => searchInput.removeEventListener('input', handleSearch));
    }
    
    const userAvatar = this.view.container.querySelector('.user-avatar');
    if (userAvatar) {
      const handleUserClick = () => {
        if (this.umbilical.onUserClick) {
          this.umbilical.onUserClick();
        }
      };
      
      userAvatar.addEventListener('click', handleUserClick);
      this.eventListeners.push(() => userAvatar.removeEventListener('click', handleUserClick));
    }
  }
  
  createPublicAPI() {
    return {
      updateTitle: (title) => {
        this.model.updateState('title', title);
        this.render();
      },
      updateSubtitle: (subtitle) => {
        this.model.updateState('subtitle', subtitle);
        this.render();
      },
      getSearchQuery: () => this.model.getState('searchQuery'),
      clearSearch: () => {
        this.model.updateState('searchQuery', '');
        this.render();
      },
      destroy: () => this.destroy()
    };
  }
  
  destroy() {
    this.eventListeners.forEach(cleanup => cleanup());
    this.view.container.innerHTML = '';
    
    if (this.umbilical.onDestroy) {
      this.umbilical.onDestroy();
    }
  }
}

export const ApplicationHeader = {
  create(umbilical) {
    // Umbilical Protocol implementation
    if (umbilical.describe) {
      const requirements = UmbilicalUtils.createRequirements();
      requirements.add('dom', 'HTMLElement', 'Container element');
      requirements.add('title', 'string', 'Application title (optional)', false);
      requirements.add('subtitle', 'string', 'Application subtitle (optional)', false);
      requirements.add('showSearch', 'boolean', 'Show global search (optional)', false);
      requirements.add('userInfo', 'object', 'User information object (optional)', false);
      requirements.add('onMount', 'function', 'Mount callback (optional)', false);
      requirements.add('onSearch', 'function', 'Search callback (optional)', false);
      requirements.add('onUserClick', 'function', 'User click callback (optional)', false);
      umbilical.describe(requirements);
      return;
    }
    
    if (umbilical.validate) {
      return umbilical.validate({
        hasDomElement: umbilical.dom && umbilical.dom.nodeType === Node.ELEMENT_NODE
      });
    }
    
    UmbilicalUtils.validateCapabilities(umbilical, ['dom'], 'ApplicationHeader');
    
    const model = new ApplicationHeaderModel(umbilical);
    const view = new ApplicationHeaderView(umbilical.dom);
    const viewModel = new ApplicationHeaderViewModel(model, view, umbilical);
    
    return viewModel.initialize();
  }
};
```

### 3. NavigationTabs Component

#### Purpose
Responsive tab navigation system that manages content panels and handles tab switching with smooth transitions.

#### Complete Implementation
```javascript
// /src/components/tool-registry/components/NavigationTabs.js
import { UmbilicalUtils } from '../../../umbilical/index.js';

class NavigationTabsModel {
  constructor(options = {}) {
    this.state = {
      tabs: options.tabs || [],
      activeTab: options.activeTab || (options.tabs?.[0]?.id) || null,
      orientation: options.orientation || 'horizontal', // 'horizontal' | 'vertical'
      variant: options.variant || 'default', // 'default' | 'pills' | 'underline'
      showIcons: options.showIcons !== false,
      closableTabs: options.closableTabs || false
    };
  }
  
  updateState(path, value) {
    const keys = path.split('.');
    let current = this.state;
    for (let i = 0; i < keys.length - 1; i++) {
      current = current[keys[i]];
    }
    current[keys[keys.length - 1]] = value;
  }
  
  getState(path = '') {
    if (!path) return this.state;
    return path.split('.').reduce((obj, key) => obj?.[key], this.state);
  }
  
  getActiveTab() {
    return this.state.tabs.find(tab => tab.id === this.state.activeTab);
  }
  
  setActiveTab(tabId) {
    if (this.state.tabs.some(tab => tab.id === tabId)) {
      this.state.activeTab = tabId;
      return true;
    }
    return false;
  }
}

class NavigationTabsView {
  constructor(container) {
    this.container = container;
    this.cssInjected = false;
    this.elements = new Map();
  }
  
  generateCSS() {
    return `
      .navigation-tabs-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
        background: var(--surface-primary);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-md);
        overflow: hidden;
      }
      
      .tabs-header {
        flex-shrink: 0;
        background: var(--surface-secondary);
        border-bottom: 0.125rem solid var(--border-subtle);
        padding: var(--spacing-md) var(--spacing-lg);
      }
      
      .tabs-list {
        display: flex;
        gap: var(--spacing-sm);
        align-items: center;
        overflow-x: auto;
        scroll-behavior: smooth;
        scrollbar-width: none;
        -ms-overflow-style: none;
      }
      
      .tabs-list::-webkit-scrollbar {
        display: none;
      }
      
      .tab-button {
        flex: 1;
        min-width: clamp(8rem, 20vw, 12rem);
        padding: var(--spacing-sm) var(--spacing-md);
        background: var(--surface-tertiary);
        color: var(--text-secondary);
        border: 0.125rem solid transparent;
        border-radius: var(--radius-md);
        font-size: var(--font-sm);
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-xs);
        transition: all 0.2s ease;
        white-space: nowrap;
        text-decoration: none;
        user-select: none;
      }
      
      .tab-button:hover {
        background: var(--surface-hover);
        color: var(--text-primary);
        border-color: var(--border-medium);
        transform: translateY(-0.0625rem);
      }
      
      .tab-button.active {
        background: var(--color-primary);
        color: white;
        border-color: var(--color-primary);
        font-weight: 600;
        box-shadow: var(--shadow-sm);
      }
      
      .tab-button.active:hover {
        background: var(--color-primary-hover);
        transform: translateY(-0.0625rem);
      }
      
      .tab-icon {
        font-size: var(--font-md);
        line-height: 1;
        flex-shrink: 0;
      }
      
      .tab-title {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex: 1;
      }
      
      .tab-close {
        width: clamp(1rem, 2.5vw, 1.25rem);
        height: clamp(1rem, 2.5vw, 1.25rem);
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: currentColor;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: var(--font-xs);
        opacity: 0.7;
        transition: all 0.2s ease;
        flex-shrink: 0;
      }
      
      .tab-close:hover {
        opacity: 1;
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }
      
      .tabs-content {
        flex: 1;
        min-height: 0;
        position: relative;
        overflow: hidden;
      }
      
      .tab-panel {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        padding: var(--spacing-lg);
        background: var(--surface-primary);
        overflow-y: auto;
        opacity: 0;
        visibility: hidden;
        transform: translateX(0.625rem);
        transition: all 0.3s ease;
      }
      
      .tab-panel.active {
        opacity: 1;
        visibility: visible;
        transform: translateX(0);
        z-index: 1;
      }
      
      .tab-panel.entering {
        opacity: 0;
        transform: translateX(0.625rem);
      }
      
      .tab-panel.exiting {
        opacity: 0;
        transform: translateX(-0.625rem);
      }
      
      /* Variant: Pills */
      .navigation-tabs-container.variant-pills .tab-button {
        border-radius: var(--radius-lg);
        min-width: clamp(6rem, 15vw, 10rem);
      }
      
      .navigation-tabs-container.variant-pills .tabs-list {
        gap: var(--spacing-xs);
      }
      
      /* Variant: Underline */
      .navigation-tabs-container.variant-underline .tabs-header {
        border-bottom: 0.125rem solid var(--border-subtle);
        background: transparent;
      }
      
      .navigation-tabs-container.variant-underline .tab-button {
        background: transparent;
        border-radius: 0;
        border-bottom: 0.1875rem solid transparent;
        padding-bottom: calc(var(--spacing-sm) - 0.1875rem);
      }
      
      .navigation-tabs-container.variant-underline .tab-button:hover {
        background: rgba(59, 130, 246, 0.05);
        border-bottom-color: var(--color-primary);
      }
      
      .navigation-tabs-container.variant-underline .tab-button.active {
        background: rgba(59, 130, 246, 0.1);
        border-bottom-color: var(--color-primary);
        color: var(--color-primary);
      }
      
      /* Responsive Behavior */
      @media (max-width: 48rem) {
        .tab-button {
          min-width: clamp(6rem, 25vw, 8rem);
          padding: var(--spacing-xs) var(--spacing-sm);
          font-size: var(--font-xs);
        }
        
        .tab-icon {
          font-size: var(--font-sm);
        }
        
        .tabs-header {
          padding: var(--spacing-sm) var(--spacing-md);
        }
        
        .tab-panel {
          padding: var(--spacing-md);
        }
      }
      
      /* Loading State */
      .tab-panel-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: var(--text-secondary);
      }
      
      .tab-panel-loading .loading-spinner {
        width: clamp(2rem, 5vw, 3rem);
        height: clamp(2rem, 5vw, 3rem);
        border: 0.25rem solid var(--border-subtle);
        border-top: 0.25rem solid var(--color-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: var(--spacing-md);
      }
      
      /* Error State */
      .tab-panel-error {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: var(--color-error);
        text-align: center;
        padding: var(--spacing-xl);
      }
      
      .tab-panel-error .error-icon {
        font-size: var(--font-xxl);
        margin-bottom: var(--spacing-md);
      }
      
      .tab-panel-error .error-title {
        font-size: var(--font-lg);
        font-weight: 600;
        margin-bottom: var(--spacing-sm);
      }
      
      .tab-panel-error .error-message {
        font-size: var(--font-md);
        color: var(--text-secondary);
        max-width: 30rem;
        line-height: 1.6;
      }
    `;
  }
  
  injectCSS() {
    if (this.cssInjected) return;
    
    const styleElement = document.createElement('style');
    styleElement.textContent = this.generateCSS();
    document.head.appendChild(styleElement);
    this.cssInjected = true;
  }
  
  render(modelData) {
    this.injectCSS();
    
    this.container.innerHTML = '';
    this.container.className = `navigation-tabs-container variant-${modelData.variant}`;
    
    // Create header with tabs
    const header = this.createTabsHeader(modelData);
    this.container.appendChild(header);
    
    // Create content area
    const content = this.createTabsContent(modelData);
    this.container.appendChild(content);
    
    // Store element references
    this.elements.set('header', header);
    this.elements.set('content', content);
    this.elements.set('tabsList', header.querySelector('.tabs-list'));
    
    return this.container;
  }
  
  createTabsHeader(modelData) {
    const header = document.createElement('div');
    header.className = 'tabs-header';
    
    const tabsList = document.createElement('div');
    tabsList.className = 'tabs-list';
    tabsList.setAttribute('role', 'tablist');
    
    modelData.tabs.forEach(tab => {
      const tabButton = this.createTabButton(tab, modelData);
      tabsList.appendChild(tabButton);
    });
    
    header.appendChild(tabsList);
    return header;
  }
  
  createTabButton(tab, modelData) {
    const button = document.createElement('button');
    button.className = `tab-button${tab.id === modelData.activeTab ? ' active' : ''}`;
    button.setAttribute('role', 'tab');
    button.setAttribute('aria-controls', `panel-${tab.id}`);
    button.setAttribute('aria-selected', tab.id === modelData.activeTab ? 'true' : 'false');
    button.dataset.tabId = tab.id;
    
    // Tab icon
    if (tab.icon && modelData.showIcons) {
      const icon = document.createElement('span');
      icon.className = 'tab-icon';
      icon.textContent = tab.icon;
      button.appendChild(icon);
    }
    
    // Tab title
    const title = document.createElement('span');
    title.className = 'tab-title';
    title.textContent = tab.title;
    button.appendChild(title);
    
    // Close button (if tabs are closable)
    if (modelData.closableTabs && tab.closable !== false) {
      const closeButton = document.createElement('button');
      closeButton.className = 'tab-close';
      closeButton.innerHTML = '×';
      closeButton.setAttribute('aria-label', `Close ${tab.title}`);
      closeButton.onclick = (e) => {
        e.stopPropagation();
        this.handleTabClose(tab.id);
      };
      button.appendChild(closeButton);
    }
    
    return button;
  }
  
  createTabsContent(modelData) {
    const content = document.createElement('div');
    content.className = 'tabs-content';
    
    modelData.tabs.forEach(tab => {
      const panel = this.createTabPanel(tab, modelData);
      content.appendChild(panel);
    });
    
    return content;
  }
  
  createTabPanel(tab, modelData) {
    const panel = document.createElement('div');
    panel.className = `tab-panel${tab.id === modelData.activeTab ? ' active' : ''}`;
    panel.setAttribute('role', 'tabpanel');
    panel.setAttribute('aria-labelledby', `tab-${tab.id}`);
    panel.id = `panel-${tab.id}`;
    panel.dataset.tabId = tab.id;
    
    // Initially show loading state
    this.showPanelLoading(panel, tab);
    
    return panel;
  }
  
  showPanelLoading(panel, tab) {
    panel.innerHTML = `
      <div class="tab-panel-loading">
        <div class="loading-spinner"></div>
        Loading ${tab.title}...
      </div>
    `;
  }
  
  showPanelError(panel, tab, error) {
    panel.innerHTML = `
      <div class="tab-panel-error">
        <div class="error-icon">⚠️</div>
        <div class="error-title">Failed to Load ${tab.title}</div>
        <div class="error-message">${error.message || 'An unexpected error occurred'}</div>
      </div>
    `;
  }
  
  showPanelContent(panel, contentElement) {
    panel.innerHTML = '';
    panel.appendChild(contentElement);
  }
  
  setActiveTab(tabId, previousTabId = null) {
    // Update tab buttons
    const buttons = this.elements.get('tabsList')?.querySelectorAll('.tab-button');
    buttons?.forEach(button => {
      const isActive = button.dataset.tabId === tabId;
      button.classList.toggle('active', isActive);
      button.setAttribute('aria-selected', isActive ? 'true' : 'false');
    });
    
    // Update panels with animation
    const panels = this.elements.get('content')?.querySelectorAll('.tab-panel');
    panels?.forEach(panel => {
      const isActive = panel.dataset.tabId === tabId;
      
      if (isActive) {
        panel.classList.add('entering');
        requestAnimationFrame(() => {
          panel.classList.remove('entering');
          panel.classList.add('active');
        });
      } else if (panel.classList.contains('active')) {
        panel.classList.add('exiting');
        setTimeout(() => {
          panel.classList.remove('active', 'exiting');
        }, 300);
      }
    });
  }
}

class NavigationTabsViewModel {
  constructor(model, view, umbilical) {
    this.model = model;
    this.view = view;
    this.umbilical = umbilical;
    this.eventListeners = [];
    this.panelComponents = new Map();
    this.loadingPromises = new Map();
  }
  
  initialize() {
    this.render();
    this.setupEventListeners();
    this.loadInitialPanel();
    
    if (this.umbilical.onMount) {
      this.umbilical.onMount(this.createPublicAPI());
    }
    
    return this.createPublicAPI();
  }
  
  render() {
    this.view.render(this.model.getState());
  }
  
  setupEventListeners() {
    const tabsList = this.view.elements.get('tabsList');
    
    if (tabsList) {
      const handleTabClick = (event) => {
        const tabButton = event.target.closest('.tab-button');
        if (tabButton) {
          const tabId = tabButton.dataset.tabId;
          this.switchToTab(tabId);
        }
      };
      
      tabsList.addEventListener('click', handleTabClick);
      this.eventListeners.push(() => tabsList.removeEventListener('click', handleTabClick));
    }
    
    // Keyboard navigation
    const handleKeyDown = (event) => {
      if (event.target.classList.contains('tab-button')) {
        this.handleKeyboardNavigation(event);
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    this.eventListeners.push(() => document.removeEventListener('keydown', handleKeyDown));
  }
  
  handleKeyboardNavigation(event) {
    const tabs = this.model.getState('tabs');
    const currentIndex = tabs.findIndex(tab => tab.id === this.model.getState('activeTab'));
    
    let newIndex = currentIndex;
    
    switch (event.key) {
      case 'ArrowLeft':
        newIndex = currentIndex > 0 ? currentIndex - 1 : tabs.length - 1;
        break;
      case 'ArrowRight':
        newIndex = currentIndex < tabs.length - 1 ? currentIndex + 1 : 0;
        break;
      case 'Home':
        newIndex = 0;
        break;
      case 'End':
        newIndex = tabs.length - 1;
        break;
      default:
        return;
    }
    
    event.preventDefault();
    this.switchToTab(tabs[newIndex].id);
    
    // Focus the new tab button
    const newButton = this.view.container.querySelector(`[data-tab-id="${tabs[newIndex].id}"]`);
    if (newButton) {
      newButton.focus();
    }
  }
  
  async switchToTab(tabId) {
    const currentTab = this.model.getState('activeTab');
    if (currentTab === tabId) return;
    
    const tab = this.model.getState('tabs').find(t => t.id === tabId);
    if (!tab) return;
    
    // Update model state
    const previousTab = currentTab;
    this.model.setActiveTab(tabId);
    
    // Update view
    this.view.setActiveTab(tabId, previousTab);
    
    // Load panel content if not already loaded
    await this.loadPanelContent(tabId);
    
    // Notify parent component
    if (this.umbilical.onTabChange) {
      this.umbilical.onTabChange(tabId, tab);
    }
  }
  
  async loadInitialPanel() {
    const activeTabId = this.model.getState('activeTab');
    if (activeTabId) {
      await this.loadPanelContent(activeTabId);
    }
  }
  
  async loadPanelContent(tabId) {
    // Prevent duplicate loading
    if (this.loadingPromises.has(tabId)) {
      return this.loadingPromises.get(tabId);
    }
    
    const tab = this.model.getState('tabs').find(t => t.id === tabId);
    if (!tab) return;
    
    // If content is already loaded, don't reload
    if (this.panelComponents.has(tabId)) return;
    
    const panel = this.view.container.querySelector(`#panel-${tabId}`);
    if (!panel) return;
    
    // Create loading promise
    const loadingPromise = this.loadTabComponent(tab, panel);
    this.loadingPromises.set(tabId, loadingPromise);
    
    try {
      await loadingPromise;
    } catch (error) {
      console.error(`Failed to load tab ${tabId}:`, error);
      this.view.showPanelError(panel, tab, error);
    } finally {
      this.loadingPromises.delete(tabId);
    }
  }
  
  async loadTabComponent(tab, panel) {
    // Dynamic import based on tab configuration
    const componentName = tab.component;
    if (!componentName) return;
    
    try {
      // Import the component
      const module = await import(`./panels/${componentName}.js`);
      const ComponentClass = module[componentName] || module.default;
      
      if (!ComponentClass) {
        throw new Error(`Component ${componentName} not found in module`);
      }
      
      // Create container for the component
      const componentContainer = document.createElement('div');
      componentContainer.className = 'panel-component-container';
      
      // Create component instance
      const componentInstance = ComponentClass.create({
        dom: componentContainer,
        tabId: tab.id,
        onMount: () => console.log(`${componentName} mounted in tab ${tab.id}`),
        onError: (error) => {
          console.error(`${componentName} error:`, error);
          this.view.showPanelError(panel, tab, error);
        }
      });
      
      // Store component reference
      this.panelComponents.set(tab.id, componentInstance);
      
      // Show content
      this.view.showPanelContent(panel, componentContainer);
      
    } catch (error) {
      throw new Error(`Failed to load component ${componentName}: ${error.message}`);
    }
  }
  
  createPublicAPI() {
    return {
      // Navigation
      switchToTab: (tabId) => this.switchToTab(tabId),
      getActiveTab: () => this.model.getState('activeTab'),
      getTabs: () => this.model.getState('tabs'),
      
      // Tab management
      addTab: (tab) => this.addTab(tab),
      removeTab: (tabId) => this.removeTab(tabId),
      updateTab: (tabId, updates) => this.updateTab(tabId, updates),
      
      // Component access
      getTabComponent: (tabId) => this.panelComponents.get(tabId),
      
      // State
      getState: (path) => this.model.getState(path),
      
      // Cleanup
      destroy: () => this.destroy()
    };
  }
  
  addTab(tab) {
    const tabs = [...this.model.getState('tabs'), tab];
    this.model.updateState('tabs', tabs);
    this.render();
  }
  
  removeTab(tabId) {
    // Destroy component if exists
    const component = this.panelComponents.get(tabId);
    if (component && component.destroy) {
      component.destroy();
    }
    this.panelComponents.delete(tabId);
    
    // Remove from tabs array
    const tabs = this.model.getState('tabs').filter(tab => tab.id !== tabId);
    this.model.updateState('tabs', tabs);
    
    // Switch to another tab if this was active
    const activeTab = this.model.getState('activeTab');
    if (activeTab === tabId && tabs.length > 0) {
      this.switchToTab(tabs[0].id);
    }
    
    this.render();
  }
  
  updateTab(tabId, updates) {
    const tabs = this.model.getState('tabs').map(tab =>
      tab.id === tabId ? { ...tab, ...updates } : tab
    );
    this.model.updateState('tabs', tabs);
    this.render();
  }
  
  destroy() {
    // Clean up event listeners
    this.eventListeners.forEach(cleanup => cleanup());
    
    // Destroy all panel components
    this.panelComponents.forEach(component => {
      if (component.destroy) {
        component.destroy();
      }
    });
    this.panelComponents.clear();
    
    // Clear DOM
    this.view.container.innerHTML = '';
    
    if (this.umbilical.onDestroy) {
      this.umbilical.onDestroy();
    }
  }
}

export const NavigationTabs = {
  create(umbilical) {
    // Umbilical Protocol implementation
    if (umbilical.describe) {
      const requirements = UmbilicalUtils.createRequirements();
      requirements.add('dom', 'HTMLElement', 'Container element');
      requirements.add('tabs', 'array', 'Array of tab objects');
      requirements.add('activeTab', 'string', 'Initial active tab ID (optional)', false);
      requirements.add('variant', 'string', 'Tab variant: default|pills|underline (optional)', false);
      requirements.add('showIcons', 'boolean', 'Show tab icons (optional)', false);
      requirements.add('closableTabs', 'boolean', 'Enable tab closing (optional)', false);
      requirements.add('onTabChange', 'function', 'Tab change callback (optional)', false);
      requirements.add('onMount', 'function', 'Mount callback (optional)', false);
      umbilical.describe(requirements);
      return;
    }
    
    if (umbilical.validate) {
      return umbilical.validate({
        hasDomElement: umbilical.dom && umbilical.dom.nodeType === Node.ELEMENT_NODE,
        hasValidTabs: Array.isArray(umbilical.tabs) && umbilical.tabs.length > 0
      });
    }
    
    UmbilicalUtils.validateCapabilities(umbilical, ['dom', 'tabs'], 'NavigationTabs');
    
    const model = new NavigationTabsModel(umbilical);
    const view = new NavigationTabsView(umbilical.dom);
    const viewModel = new NavigationTabsViewModel(model, view, umbilical);
    
    return viewModel.initialize();
  }
};
```

## Implementation Timeline & Next Steps

### Phase 1: Foundation (Complete with above)
- ✅ ToolRegistryBrowser root component with MVVM structure
- ✅ ApplicationHeader component with responsive design
- ✅ NavigationTabs component with dynamic panel loading

### Phase 2: Panel Components (Next Steps)
- **ToolSearchPanel** - Advanced search interface with filtering
- **ModuleBrowserPanel** - Hierarchical module explorer
- **ToolDetailsPanel** - Comprehensive tool information display
- **AdministrationPanel** - System management interface

### Phase 3: Data Integration
- WebSocket connection management
- Real-time data synchronization
- State persistence and restoration
- Error handling and retry logic

### Phase 4: Polish & Optimization
- Performance optimization
- Accessibility compliance (WCAG 2.1 AA)
- Cross-browser testing
- Mobile responsiveness verification

## Key Success Criteria

### ✅ Architecture Compliance
- Zero hardcoded HTML in main application
- All styling through CSS classes with responsive units
- Strict MVVM separation in all components
- Umbilical Protocol implementation for all components

### ✅ Responsive Design
- Fluid scaling from 320px to 4K+ displays
- No media queries needed (pure responsive units)
- Typography scaling with clamp() functions
- Component-level responsive behavior

### ✅ Code Quality
- TypeScript-ready ES6 modules
- Comprehensive error handling
- Memory leak prevention
- Clean separation of concerns

This design document provides the complete blueprint for building a professional, maintainable, and fully responsive Tool Registry Browser using proper MVVM architecture and modern web development practices.