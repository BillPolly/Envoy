/**
 * ExecutionControlPanel Integration Tests
 * Tests execution management and control integration with actors and execution system
 */

import { jest } from '@jest/globals';
import { ExecutionControlPanel } from '../../src/components/tool-registry/components/panels/ExecutionControlPanel.js';

describe('ExecutionControlPanel Integration Tests', () => {
  let component;
  let mockUmbilical;
  let mockExecutionActor;
  let dom;

  beforeEach(async () => {
    // Create DOM container
    dom = document.createElement('div');
    dom.style.width = '800px';
    dom.style.height = '600px';
    document.body.appendChild(dom);

    // Create mock execution actor
    mockExecutionActor = {
      sendMessage: jest.fn(),
      onMessage: jest.fn(),
      isConnected: jest.fn(() => true),
      startExecution: jest.fn(),
      pauseExecution: jest.fn(),
      resumeExecution: jest.fn(),
      stopExecution: jest.fn(),
      stepExecution: jest.fn()
    };

    // Create mock umbilical with execution event handlers
    mockUmbilical = {
      dom,
      executionActor: mockExecutionActor,
      onMount: jest.fn(),
      onExecutionStart: jest.fn(),
      onExecutionPause: jest.fn(),
      onExecutionResume: jest.fn(),
      onExecutionStop: jest.fn(),
      onExecutionComplete: jest.fn(),
      onExecutionError: jest.fn(),
      onTaskProgress: jest.fn(),
      onLogEntry: jest.fn(),
      onDestroy: jest.fn()
    };

    // Initialize component
    component = await ExecutionControlPanel.create(mockUmbilical);
  });

  afterEach(() => {
    if (component && component.destroy) {
      component.destroy();
    }
    if (dom.parentNode) {
      dom.parentNode.removeChild(dom);
    }
  });

  describe('Plan Execution Lifecycle', () => {
    test('should manage complete execution lifecycle from start to completion', async () => {
      const testPlan = {
        id: 'test-plan-123',
        name: 'Complete Integration Test Plan',
        goal: 'Test full execution lifecycle',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Root task',
            children: [
              { id: 'task1', description: 'Initialize system', estimatedDuration: 5000 },
              { id: 'task2', description: 'Process data', estimatedDuration: 10000 },
              { id: 'task3', description: 'Generate output', estimatedDuration: 3000 }
            ]
          }
        }
      };

      // Set plan for execution
      const setPlanResult = component.api.setPlan(testPlan);
      expect(setPlanResult.success).toBe(true);
      expect(component.api.getPlan()).toEqual(testPlan);

      // Verify initial state
      expect(component.api.getExecutionStatus()).toBe('idle');
      expect(component.api.getExecutionId()).toBeNull();

      // Configure execution options
      component.api.setExecutionMode('sequential');
      component.api.setExecutionOption('continueOnError', false);
      component.api.setExecutionOption('maxRetries', 2);
      component.api.setExecutionOption('timeout', 60000);

      // Start execution
      mockExecutionActor.startExecution.mockResolvedValue({ 
        success: true, 
        executionId: 'exec-123' 
      });

      const startResult = await component.api.startExecution();
      expect(startResult.success).toBe(true);
      expect(component.api.getExecutionStatus()).toBe('running');
      expect(component.api.getExecutionId()).toBe('exec-123');

      // Verify execution started callback
      expect(mockUmbilical.onExecutionStart).toHaveBeenCalledWith(
        expect.objectContaining({ executionId: 'exec-123' })
      );

      // Simulate task progress updates
      component.api.updateTaskProgress('task1', {
        status: 'running',
        progress: 0.5,
        startTime: Date.now()
      });

      expect(component.api.getActiveTask()).toEqual(
        expect.objectContaining({ id: 'task1', status: 'running' })
      );

      // Complete first task
      component.api.updateTaskProgress('task1', {
        status: 'completed',
        progress: 1.0,
        endTime: Date.now()
      });

      const completedTasks = component.api.getCompletedTasks();
      expect(completedTasks).toHaveLength(1);
      expect(completedTasks[0].id).toBe('task1');

      // Start and complete remaining tasks
      component.api.updateTaskProgress('task2', { status: 'completed', progress: 1.0 });
      component.api.updateTaskProgress('task3', { status: 'completed', progress: 1.0 });

      // Stop execution
      mockExecutionActor.stopExecution.mockResolvedValue({ success: true });
      
      const stopResult = await component.api.stopExecution();
      expect(stopResult.success).toBe(true);
      expect(component.api.getExecutionStatus()).toBe('stopped');

      // Verify execution metrics
      const metrics = component.api.getExecutionMetrics();
      expect(metrics.totalTasks).toBe(3);
      expect(metrics.successRate).toBeGreaterThan(0);
    });

    test('should handle execution with failures and error recovery', async () => {
      const failurePlan = {
        id: 'failure-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Failure test plan',
            children: [
              { id: 'success-task', description: 'Successful task' },
              { id: 'fail-task', description: 'Failing task' },
              { id: 'recovery-task', description: 'Recovery task' }
            ]
          }
        }
      };

      component.api.setPlan(failurePlan);
      component.api.setExecutionOption('continueOnError', true);
      component.api.setExecutionOption('maxRetries', 2);

      // Start execution
      mockExecutionActor.startExecution.mockResolvedValue({ 
        success: true, 
        executionId: 'fail-exec-456' 
      });

      await component.api.startExecution();

      // Simulate successful task
      component.api.updateTaskProgress('success-task', { status: 'completed', progress: 1.0 });

      // Simulate failing task
      component.api.updateTaskProgress('fail-task', {
        status: 'failed',
        progress: 0.3,
        error: 'Network timeout occurred',
        retryCount: 1
      });

      const failedTasks = component.api.getFailedTasks();
      expect(failedTasks).toHaveLength(1);
      expect(failedTasks[0].error).toBe('Network timeout occurred');

      // Verify error callback was triggered
      expect(mockUmbilical.onExecutionError).toHaveBeenCalledWith(
        expect.objectContaining({
          taskId: 'fail-task',
          error: 'Network timeout occurred'
        })
      );

      // Continue with recovery task (since continueOnError is true)
      component.api.updateTaskProgress('recovery-task', { status: 'completed', progress: 1.0 });

      const completedTasks = component.api.getCompletedTasks();
      expect(completedTasks).toHaveLength(2); // success-task and recovery-task
    });

    test('should support pause and resume functionality', async () => {
      const pausePlan = {
        id: 'pause-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Pausable plan',
            children: [
              { id: 'long-task', description: 'Long running task' }
            ]
          }
        }
      };

      component.setPlan(pausePlan);
      
      mockExecutionActor.startExecution.mockResolvedValue({ 
        success: true, 
        executionId: 'pause-exec' 
      });

      await component.startExecution();

      // Start long task
      component.updateTaskProgress('long-task', { status: 'running', progress: 0.3 });

      // Pause execution
      mockExecutionActor.pauseExecution.mockResolvedValue({ success: true });
      
      const pauseResult = await component.pauseExecution();
      expect(pauseResult.success).toBe(true);
      expect(component.getExecutionStatus()).toBe('paused');
      expect(mockUmbilical.onExecutionPause).toHaveBeenCalled();

      // Resume execution
      mockExecutionActor.resumeExecution.mockResolvedValue({ success: true });
      
      const resumeResult = await component.resumeExecution();
      expect(resumeResult.success).toBe(true);
      expect(component.getExecutionStatus()).toBe('running');
      expect(mockUmbilical.onExecutionResume).toHaveBeenCalled();

      // Complete the task
      component.updateTaskProgress('long-task', { status: 'completed', progress: 1.0 });
    });
  });

  describe('Execution Control Features', () => {
    test('should support step-by-step execution mode', async () => {
      const stepPlan = {
        id: 'step-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Step-by-step plan',
            children: [
              { id: 'step1', description: 'Step 1' },
              { id: 'step2', description: 'Step 2' },
              { id: 'step3', description: 'Step 3' }
            ]
          }
        }
      };

      component.setPlan(stepPlan);
      component.setExecutionMode('step');

      mockExecutionActor.startExecution.mockResolvedValue({ 
        success: true, 
        executionId: 'step-exec' 
      });

      await component.startExecution();

      // Execute one step at a time
      mockExecutionActor.stepExecution.mockResolvedValue({ 
        success: true, 
        executedTask: 'step1' 
      });

      const step1Result = await component.stepExecution();
      expect(step1Result.success).toBe(true);

      // Simulate step completion
      component.updateTaskProgress('step1', { status: 'completed', progress: 1.0 });

      // Execute next step
      const step2Result = await component.stepExecution();
      expect(step2Result.success).toBe(true);

      // Verify step mode execution
      expect(component.getExecutionMode()).toBe('step');
    });

    test('should support execution with breakpoints', async () => {
      const breakpointPlan = {
        id: 'breakpoint-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Plan with breakpoints',
            children: [
              { id: 'before-break', description: 'Before breakpoint' },
              { id: 'at-break', description: 'At breakpoint' },
              { id: 'after-break', description: 'After breakpoint' }
            ]
          }
        }
      };

      component.setPlan(breakpointPlan);

      // Set breakpoint
      component.setBreakpoint('at-break');
      expect(component.getBreakpoints()).toContain('at-break');

      mockExecutionActor.startExecution.mockResolvedValue({ 
        success: true, 
        executionId: 'break-exec' 
      });

      await component.startExecution();

      // Execute until breakpoint
      component.updateTaskProgress('before-break', { status: 'completed', progress: 1.0 });

      // Should pause at breakpoint
      component.updateTaskProgress('at-break', { status: 'paused', progress: 0 });
      expect(component.getExecutionStatus()).toBe('paused');

      // Remove breakpoint and continue
      component.removeBreakpoint('at-break');
      expect(component.getBreakpoints()).not.toContain('at-break');

      await component.resumeExecution();
      component.updateTaskProgress('at-break', { status: 'completed', progress: 1.0 });
      component.updateTaskProgress('after-break', { status: 'completed', progress: 1.0 });
    });

    test('should support dry run mode', async () => {
      const dryRunPlan = {
        id: 'dry-run-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Dry run test',
            children: [
              { id: 'dry-task', description: 'Dry run task' }
            ]
          }
        }
      };

      component.setPlan(dryRunPlan);
      component.setExecutionOption('dryRun', true);

      expect(component.getExecutionOptions().dryRun).toBe(true);

      mockExecutionActor.startExecution.mockResolvedValue({ 
        success: true, 
        executionId: 'dry-exec',
        dryRun: true 
      });

      const startResult = await component.startExecution();
      expect(startResult.success).toBe(true);

      // In dry run, tasks should be simulated
      component.updateTaskProgress('dry-task', { 
        status: 'completed', 
        progress: 1.0,
        simulated: true 
      });

      const log = component.getExecutionLog();
      expect(log.some(entry => entry.message.includes('DRY RUN'))).toBe(true);
    });
  });

  describe('Real-time Monitoring Integration', () => {
    test('should track execution metrics in real-time', () => {
      const metricsPlan = {
        id: 'metrics-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Metrics tracking plan',
            children: [
              { id: 'fast-task', description: 'Fast task' },
              { id: 'slow-task', description: 'Slow task' }
            ]
          }
        }
      };

      component.setPlan(metricsPlan);

      // Start tracking metrics
      const startTime = Date.now();
      component.model.updateState('executionMetrics', {
        startTime,
        endTime: null,
        duration: 0,
        totalTasks: 2,
        successRate: 0
      });

      // Simulate task execution with timing
      component.updateTaskProgress('fast-task', {
        status: 'running',
        progress: 0,
        startTime: startTime + 1000
      });

      component.updateTaskProgress('fast-task', {
        status: 'completed',
        progress: 1.0,
        endTime: startTime + 3000
      });

      // Update metrics
      const metrics = component.getExecutionMetrics();
      expect(metrics.totalTasks).toBe(2);
      expect(metrics.startTime).toBe(startTime);

      // Complete second task
      component.updateTaskProgress('slow-task', {
        status: 'completed',
        progress: 1.0,
        endTime: startTime + 8000
      });

      // Verify final metrics
      const completedTasks = component.getCompletedTasks();
      expect(completedTasks).toHaveLength(2);
    });

    test('should provide detailed execution logging', () => {
      const loggingPlan = {
        id: 'logging-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Logging test plan',
            children: [
              { id: 'logged-task', description: 'Task with logging' }
            ]
          }
        }
      };

      component.setPlan(loggingPlan);

      // Add various log entries
      component.addLogEntry('info', 'Execution started', { timestamp: Date.now() });
      component.addLogEntry('debug', 'Task initialized', { taskId: 'logged-task' });
      component.addLogEntry('warn', 'Performance warning', { metric: 'memory_usage' });
      component.addLogEntry('error', 'Temporary error', { retryable: true });

      const log = component.getExecutionLog();
      expect(log).toHaveLength(4);
      expect(log[0].level).toBe('info');
      expect(log[1].level).toBe('debug');
      expect(log[2].level).toBe('warn');
      expect(log[3].level).toBe('error');

      // Verify log entries trigger callbacks
      expect(mockUmbilical.onLogEntry).toHaveBeenCalledTimes(4);

      // Clear log
      component.clearLog();
      expect(component.getExecutionLog()).toHaveLength(0);
    });

    test('should handle concurrent task execution monitoring', () => {
      const concurrentPlan = {
        id: 'concurrent-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Concurrent execution plan',
            children: [
              { id: 'parallel1', description: 'Parallel task 1' },
              { id: 'parallel2', description: 'Parallel task 2' },
              { id: 'parallel3', description: 'Parallel task 3' }
            ]
          }
        }
      };

      component.setPlan(concurrentPlan);
      component.setExecutionMode('parallel');
      component.setExecutionOption('parallelLimit', 3);

      const startTime = Date.now();

      // Start all tasks concurrently
      component.updateTaskProgress('parallel1', { status: 'running', progress: 0, startTime });
      component.updateTaskProgress('parallel2', { status: 'running', progress: 0, startTime });
      component.updateTaskProgress('parallel3', { status: 'running', progress: 0, startTime });

      // Update progress at different rates
      component.updateTaskProgress('parallel1', { status: 'running', progress: 0.8 });
      component.updateTaskProgress('parallel2', { status: 'running', progress: 0.3 });
      component.updateTaskProgress('parallel3', { status: 'running', progress: 0.6 });

      // Complete in different order
      component.updateTaskProgress('parallel2', { status: 'completed', progress: 1.0 });
      component.updateTaskProgress('parallel1', { status: 'completed', progress: 1.0 });
      component.updateTaskProgress('parallel3', { status: 'completed', progress: 1.0 });

      const completedTasks = component.getCompletedTasks();
      expect(completedTasks).toHaveLength(3);
      expect(component.getExecutionMode()).toBe('parallel');
    });
  });

  describe('Actor Integration', () => {
    test('should communicate with execution actor for plan execution', async () => {
      const actorPlan = {
        id: 'actor-integration-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Actor integration test',
            children: [
              { id: 'actor-task', description: 'Task handled by actor' }
            ]
          }
        }
      };

      component.setPlan(actorPlan);

      // Test actor communication
      expect(mockExecutionActor.isConnected()).toBe(true);

      // Start execution through actor
      mockExecutionActor.startExecution.mockResolvedValue({
        success: true,
        executionId: 'actor-exec-789',
        message: 'Execution started successfully'
      });

      const result = await component.startExecution();
      expect(result.success).toBe(true);
      expect(mockExecutionActor.startExecution).toHaveBeenCalledWith(
        expect.objectContaining({
          planId: 'actor-integration-plan',
          mode: component.getExecutionMode(),
          options: component.getExecutionOptions()
        })
      );

      // Test pause through actor
      mockExecutionActor.pauseExecution.mockResolvedValue({ success: true });
      await component.pauseExecution();
      expect(mockExecutionActor.pauseExecution).toHaveBeenCalledWith('actor-exec-789');

      // Test resume through actor
      mockExecutionActor.resumeExecution.mockResolvedValue({ success: true });
      await component.resumeExecution();
      expect(mockExecutionActor.resumeExecution).toHaveBeenCalledWith('actor-exec-789');

      // Test stop through actor
      mockExecutionActor.stopExecution.mockResolvedValue({ success: true });
      await component.stopExecution();
      expect(mockExecutionActor.stopExecution).toHaveBeenCalledWith('actor-exec-789');
    });

    test('should handle actor communication failures gracefully', async () => {
      const errorPlan = {
        id: 'error-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Error handling test',
            children: [
              { id: 'error-task', description: 'Task that will fail' }
            ]
          }
        }
      };

      component.setPlan(errorPlan);

      // Simulate actor failure
      mockExecutionActor.startExecution.mockRejectedValue(
        new Error('Actor communication failed')
      );

      const result = await component.startExecution();
      expect(result.success).toBe(false);
      expect(result.error).toContain('Actor communication failed');

      // Verify error was logged
      const log = component.getExecutionLog();
      const errorLog = log.find(entry => entry.level === 'error');
      expect(errorLog).toBeDefined();
      expect(errorLog.message).toContain('Failed to start execution');
    });

    test('should reconnect to actor after disconnection', async () => {
      // Simulate disconnection
      mockExecutionActor.isConnected.mockReturnValue(false);

      const reconnectPlan = {
        id: 'reconnect-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Reconnection test',
            children: [
              { id: 'reconnect-task', description: 'Task after reconnection' }
            ]
          }
        }
      };

      component.setPlan(reconnectPlan);

      // Attempt execution while disconnected
      const disconnectedResult = await component.startExecution();
      expect(disconnectedResult.success).toBe(false);
      expect(disconnectedResult.error).toContain('not connected');

      // Simulate reconnection
      mockExecutionActor.isConnected.mockReturnValue(true);
      mockExecutionActor.startExecution.mockResolvedValue({
        success: true,
        executionId: 'reconnect-exec'
      });

      // Retry execution after reconnection
      const reconnectedResult = await component.startExecution();
      expect(reconnectedResult.success).toBe(true);
    });
  });

  describe('Configuration and Environment', () => {
    test('should support different execution environments', () => {
      component.setEnvironment('production');
      expect(component.getEnvironment()).toBe('production');

      component.setEnvironment('development');
      expect(component.getEnvironment()).toBe('development');

      component.setEnvironment('testing');
      expect(component.getEnvironment()).toBe('testing');
    });

    test('should manage execution variables and context', () => {
      // Set execution variables
      component.setVariable('API_URL', 'https://api.example.com');
      component.setVariable('TIMEOUT', 30000);
      component.setVariable('DEBUG_MODE', true);

      const variables = component.getVariables();
      expect(variables.API_URL).toBe('https://api.example.com');
      expect(variables.TIMEOUT).toBe(30000);
      expect(variables.DEBUG_MODE).toBe(true);

      // Update variable
      component.setVariable('TIMEOUT', 60000);
      expect(component.getVariables().TIMEOUT).toBe(60000);

      // Remove variable
      component.removeVariable('DEBUG_MODE');
      expect(component.getVariables().DEBUG_MODE).toBeUndefined();

      // Clear all variables
      component.clearVariables();
      expect(Object.keys(component.getVariables())).toHaveLength(0);
    });

    test('should validate execution configuration', () => {
      const invalidPlan = null;
      const setPlanResult = component.setPlan(invalidPlan);
      expect(setPlanResult.success).toBe(false);
      expect(setPlanResult.error).toContain('Plan cannot be null');

      // Test invalid execution options
      const setOptionResult = component.setExecutionOption('invalidOption', 'value');
      expect(setOptionResult.success).toBe(false);
      expect(setOptionResult.error).toContain('Invalid execution option');

      // Test invalid execution mode
      const setModeResult = component.setExecutionMode('invalidMode');
      expect(setModeResult.success).toBe(false);
      expect(setModeResult.error).toContain('Invalid execution mode');
    });
  });

  describe('Error Handling and Recovery', () => {
    test('should handle execution reset and cleanup', async () => {
      const resetPlan = {
        id: 'reset-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Reset test plan',
            children: [
              { id: 'reset-task', description: 'Task to be reset' }
            ]
          }
        }
      };

      component.setPlan(resetPlan);

      mockExecutionActor.startExecution.mockResolvedValue({
        success: true,
        executionId: 'reset-exec'
      });

      // Start execution and simulate some progress
      await component.startExecution();
      component.updateTaskProgress('reset-task', { status: 'running', progress: 0.5 });
      component.addLogEntry('info', 'Task in progress');

      // Reset execution
      const resetResult = component.resetExecution();
      expect(resetResult.success).toBe(true);

      // Verify reset state
      expect(component.getExecutionStatus()).toBe('idle');
      expect(component.getExecutionId()).toBeNull();
      expect(component.getActiveTask()).toBeNull();
      expect(component.getCompletedTasks()).toHaveLength(0);
      expect(component.getFailedTasks()).toHaveLength(0);
      expect(component.getExecutionLog()).toHaveLength(0);
    });

    test('should maintain state consistency during errors', async () => {
      const consistencyPlan = {
        id: 'consistency-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'State consistency test',
            children: [
              { id: 'consistent-task', description: 'State consistency task' }
            ]
          }
        }
      };

      component.setPlan(consistencyPlan);

      // Start execution
      mockExecutionActor.startExecution.mockResolvedValue({
        success: true,
        executionId: 'consistency-exec'
      });

      await component.startExecution();

      // Simulate error during execution
      component.updateTaskProgress('consistent-task', {
        status: 'failed',
        progress: 0.2,
        error: 'Unexpected error occurred'
      });

      // Verify state remains consistent
      expect(component.getExecutionStatus()).toBe('running'); // Should still be running
      expect(component.getFailedTasks()).toHaveLength(1);
      expect(component.getCompletedTasks()).toHaveLength(0);

      // Recovery: retry the task
      component.updateTaskProgress('consistent-task', {
        status: 'running',
        progress: 0,
        retryCount: 1
      });

      component.updateTaskProgress('consistent-task', {
        status: 'completed',
        progress: 1.0
      });

      // Verify recovery
      expect(component.getFailedTasks()).toHaveLength(0); // Should be moved to completed
      expect(component.getCompletedTasks()).toHaveLength(1);
    });
  });

  describe('Performance and Scalability', () => {
    test('should handle large execution plans efficiently', () => {
      // Create a large plan with 100 tasks
      const largePlan = {
        id: 'large-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Large execution plan',
            children: Array.from({ length: 100 }, (_, i) => ({
              id: `task-${i}`,
              description: `Task ${i}`,
              estimatedDuration: 1000 + (i * 100)
            }))
          }
        }
      };

      const startTime = Date.now();
      component.setPlan(largePlan);

      // Simulate rapid task updates
      for (let i = 0; i < 100; i++) {
        component.updateTaskProgress(`task-${i}`, {
          status: i < 50 ? 'completed' : 'running',
          progress: i < 50 ? 1.0 : Math.random()
        });
      }

      const operationTime = Date.now() - startTime;

      // Should handle large plans efficiently
      expect(operationTime).toBeLessThan(2000);

      // Verify state is correct
      expect(component.getCompletedTasks()).toHaveLength(50);
      expect(component.getPlan().hierarchy.root.children).toHaveLength(100);
    });

    test('should manage memory efficiently during long executions', () => {
      const memoryPlan = {
        id: 'memory-plan',
        hierarchy: {
          root: {
            id: 'root',
            description: 'Memory management test',
            children: [
              { id: 'memory-task', description: 'Memory intensive task' }
            ]
          }
        }
      };

      component.setPlan(memoryPlan);

      // Simulate many log entries (potential memory issue)
      for (let i = 0; i < 1000; i++) {
        component.addLogEntry('debug', `Log entry ${i}`, { iteration: i });
      }

      // Verify log management
      const log = component.getExecutionLog();
      expect(log.length).toBeLessThanOrEqual(1000); // Should not grow indefinitely

      // Clear log to free memory
      component.clearLog();
      expect(component.getExecutionLog()).toHaveLength(0);
    });
  });
});