# Deployment Guide

## Overview

This guide covers deployment options for projects using the Code Agent, including configuration, optimization, and best practices for production environments.

## Table of Contents

1. [Pre-Deployment Checklist](#pre-deployment-checklist)
2. [Environment Configuration](#environment-configuration)
3. [Deployment Options](#deployment-options)
4. [Production Configuration](#production-configuration)
5. [Security Hardening](#security-hardening)
6. [Performance Optimization](#performance-optimization)
7. [Monitoring Setup](#monitoring-setup)
8. [Troubleshooting](#troubleshooting)

## Pre-Deployment Checklist

Before deploying code generated by Code Agent:

### Code Quality
- [ ] All tests pass (`npm test`)
- [ ] ESLint shows no errors (`npm run lint`)
- [ ] Test coverage meets requirements (>80%)
- [ ] Security scan completed (`npm run security:scan`)
- [ ] Performance benchmarks meet targets

### Security
- [ ] No hardcoded secrets or API keys
- [ ] Environment variables properly configured
- [ ] Dependencies updated (`npm audit fix`)
- [ ] HTTPS configured for all endpoints
- [ ] Authentication implemented for protected routes

### Infrastructure
- [ ] Server requirements documented
- [ ] Database connection tested
- [ ] Load balancing configured (if needed)
- [ ] Backup strategy in place
- [ ] Monitoring tools configured

## Environment Configuration

### Development vs Production

Create separate environment files:

```bash
# .env.development
NODE_ENV=development
PORT=3000
DATABASE_URL=mongodb://localhost:27017/myapp-dev
LOG_LEVEL=debug
ENABLE_MOCKS=true

# .env.production
NODE_ENV=production
PORT=8080
DATABASE_URL=mongodb+srv://user:pass@cluster.mongodb.net/myapp
LOG_LEVEL=error
ENABLE_MOCKS=false
ENABLE_MONITORING=true
```

### Environment Variables Template

```bash
# Application
NODE_ENV=production
APP_NAME=my-application
APP_VERSION=1.0.0

# Server
PORT=8080
HOST=0.0.0.0
CLUSTER_MODE=true
WORKER_COUNT=4

# Database
DATABASE_URL=
DATABASE_POOL_SIZE=10
DATABASE_TIMEOUT=30000

# Security
JWT_SECRET=
SESSION_SECRET=
CORS_ORIGIN=https://myapp.com
RATE_LIMIT_WINDOW=900000
RATE_LIMIT_MAX=100

# Monitoring
ENABLE_MONITORING=true
METRICS_PORT=9090
LOG_LEVEL=info
SENTRY_DSN=

# Code Agent Specific
ENABLE_ENHANCED_TESTING=false
RUNTIME_TIMEOUT=300000
MAX_WORKERS=4
```

## Deployment Options

### 1. Node.js Server (PM2)

```bash
# Install PM2
npm install -g pm2

# Start application
pm2 start ecosystem.config.js --env production

# Monitor
pm2 monit
```

**ecosystem.config.js:**
```javascript
module.exports = {
  apps: [{
    name: 'myapp',
    script: './server.js',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'development'
    },
    env_production: {
      NODE_ENV: 'production'
    },
    error_file: './logs/err.log',
    out_file: './logs/out.log',
    log_file: './logs/combined.log',
    time: true
  }]
};
```

### 2. Docker Deployment

**Dockerfile:**
```dockerfile
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# Runtime stage
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/node_modules ./node_modules
COPY . .

# Security
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001
USER nodejs

EXPOSE 8080
CMD ["node", "server.js"]
```

**docker-compose.yml:**
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

### 3. Cloud Platforms

#### AWS Elastic Beanstalk
```bash
# Install EB CLI
pip install awsebcli

# Initialize
eb init -p node.js-18 myapp

# Create environment
eb create production

# Deploy
eb deploy
```

#### Heroku
```bash
# Create app
heroku create myapp

# Set buildpack
heroku buildpacks:set heroku/nodejs

# Configure
heroku config:set NODE_ENV=production

# Deploy
git push heroku main
```

#### Google Cloud Run
```bash
# Build container
gcloud builds submit --tag gcr.io/PROJECT-ID/myapp

# Deploy
gcloud run deploy --image gcr.io/PROJECT-ID/myapp --platform managed
```

## Production Configuration

### 1. Server Configuration

**server.js enhancements:**
```javascript
import express from 'express';
import helmet from 'helmet';
import compression from 'compression';
import rateLimit from 'express-rate-limit';

const app = express();

// Security
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
}));

// Compression
app.use(compression());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100,
  standardHeaders: true,
  legacyHeaders: false,
});
app.use('/api', limiter);

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM signal received: closing HTTP server');
  server.close(() => {
    console.log('HTTP server closed');
    process.exit(0);
  });
});
```

### 2. Database Configuration

**MongoDB production settings:**
```javascript
import mongoose from 'mongoose';

const options = {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  maxPoolSize: 10,
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
  family: 4
};

mongoose.connect(process.env.DATABASE_URL, options);

// Connection monitoring
mongoose.connection.on('connected', () => {
  console.log('MongoDB connected');
});

mongoose.connection.on('error', (err) => {
  console.error('MongoDB error:', err);
});

mongoose.connection.on('disconnected', () => {
  console.log('MongoDB disconnected');
});
```

### 3. Logging Configuration

**Production logging:**
```javascript
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.json(),
  defaultMeta: { service: 'myapp' },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple(),
  }));
}
```

## Security Hardening

### 1. HTTPS Configuration

**Nginx SSL configuration:**
```nginx
server {
    listen 443 ssl http2;
    server_name myapp.com;

    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    # SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    
    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    location / {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
```

### 2. Security Checklist

- [ ] Use HTTPS everywhere
- [ ] Implement CSP headers
- [ ] Enable CORS properly
- [ ] Use secure session configuration
- [ ] Implement rate limiting
- [ ] Validate all inputs
- [ ] Sanitize outputs
- [ ] Use parameterized queries
- [ ] Keep dependencies updated
- [ ] Regular security audits

## Performance Optimization

### 1. Caching Strategy

**Redis caching:**
```javascript
import redis from 'redis';
import { promisify } from 'util';

const client = redis.createClient({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
});

const getAsync = promisify(client.get).bind(client);
const setAsync = promisify(client.set).bind(client);

// Cache middleware
const cache = (duration = 300) => async (req, res, next) => {
  const key = `cache:${req.originalUrl}`;
  
  try {
    const cached = await getAsync(key);
    if (cached) {
      return res.json(JSON.parse(cached));
    }
  } catch (err) {
    console.error('Cache error:', err);
  }
  
  res.sendResponse = res.json;
  res.json = async (body) => {
    await setAsync(key, JSON.stringify(body), 'EX', duration);
    res.sendResponse(body);
  };
  
  next();
};
```

### 2. Database Optimization

```javascript
// Indexing
schema.index({ createdAt: -1 });
schema.index({ userId: 1, status: 1 });

// Query optimization
const users = await User.find({ status: 'active' })
  .select('name email')
  .limit(100)
  .lean(); // Returns plain objects

// Aggregation pipeline
const stats = await Order.aggregate([
  { $match: { status: 'completed' } },
  { $group: {
    _id: '$userId',
    total: { $sum: '$amount' }
  }},
  { $sort: { total: -1 } },
  { $limit: 10 }
]);
```

### 3. Asset Optimization

```javascript
// Compression
import compression from 'compression';
app.use(compression({
  filter: (req, res) => {
    if (req.headers['x-no-compression']) {
      return false;
    }
    return compression.filter(req, res);
  }
}));

// Static file caching
app.use(express.static('public', {
  maxAge: '1y',
  etag: false
}));
```

## Monitoring Setup

### 1. Application Monitoring

```javascript
import { PerformanceMonitor } from '@jsenvoy/code-agent';

const monitor = new PerformanceMonitor({
  sampleInterval: 5000,
  enableAutoReporting: true,
  reportInterval: 300000
});

monitor.start();

// Custom metrics
monitor.addCustomMetric('api_requests');
monitor.addCustomMetric('api_response_time');

// Middleware
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    monitor.recordCustomMetric('api_requests', 1);
    monitor.recordCustomMetric('api_response_time', duration);
  });
  
  next();
});

// Alerts
monitor.addAlertRule({
  name: 'High Response Time',
  metric: 'api_response_time',
  condition: 'gt',
  threshold: 1000,
  duration: 60000,
  severity: 'warning'
});
```

### 2. Infrastructure Monitoring

**Prometheus configuration:**
```yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'myapp'
    static_configs:
      - targets: ['localhost:9090']
```

**Grafana dashboard:**
```json
{
  "dashboard": {
    "title": "MyApp Monitoring",
    "panels": [
      {
        "title": "Request Rate",
        "targets": [
          {
            "expr": "rate(api_requests_total[5m])"
          }
        ]
      },
      {
        "title": "Response Time",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, api_response_time)"
          }
        ]
      }
    ]
  }
}
```

## Troubleshooting

### Common Issues

#### 1. Memory Leaks
```bash
# Heap snapshot
node --inspect server.js
# Open chrome://inspect

# Heap dump
node --heapsnapshot-signal=SIGUSR2 server.js
kill -USR2 <pid>
```

#### 2. High CPU Usage
```bash
# CPU profiling
node --prof server.js
node --prof-process isolate-*.log > profile.txt

# Flame graph
npm install -g 0x
0x server.js
```

#### 3. Connection Issues
```javascript
// Connection pooling
const pool = {
  min: 2,
  max: 10,
  idleTimeoutMillis: 30000
};

// Retry logic
const connectWithRetry = () => {
  mongoose.connect(uri, options)
    .catch(err => {
      console.error('DB connection failed, retrying in 5s', err);
      setTimeout(connectWithRetry, 5000);
    });
};
```

### Debug Mode

Enable debug logging:
```bash
DEBUG=myapp:* NODE_ENV=production node server.js
```

### Health Checks

Implement comprehensive health checks:
```javascript
app.get('/health/detailed', async (req, res) => {
  const health = {
    uptime: process.uptime(),
    timestamp: Date.now(),
    status: 'ok',
    checks: {}
  };
  
  // Database check
  try {
    await mongoose.connection.db.admin().ping();
    health.checks.database = 'healthy';
  } catch (err) {
    health.checks.database = 'unhealthy';
    health.status = 'degraded';
  }
  
  // Memory check
  const mem = process.memoryUsage();
  health.checks.memory = {
    heapUsed: mem.heapUsed,
    heapTotal: mem.heapTotal,
    rss: mem.rss
  };
  
  res.status(health.status === 'ok' ? 200 : 503).json(health);
});
```

## Best Practices

1. **Use environment variables** for all configuration
2. **Implement graceful shutdown** for all services
3. **Set up proper logging** with appropriate levels
4. **Monitor everything** - errors, performance, business metrics
5. **Automate deployments** with CI/CD pipelines
6. **Regular backups** of data and configurations
7. **Load testing** before major releases
8. **Security scanning** as part of deployment
9. **Documentation** of deployment procedures
10. **Rollback plan** for failed deployments

## Next Steps

1. Review the [Security Guide](./SECURITY.md)
2. Set up [Monitoring](./MONITORING.md)
3. Configure [CI/CD Pipeline](./CICD.md)
4. Plan for [Scaling](./SCALING.md)