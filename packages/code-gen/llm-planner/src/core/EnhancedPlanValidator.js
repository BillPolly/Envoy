/**
 * EnhancedPlanValidator - Comprehensive validation system for generated plans
 * 
 * This class provides enhanced validation functionality for plans generated by the LLM planner.
 * It uses a pipeline of specialized validators to ensure plans are correct, complete, and ready for execution.
 */

import { Plan } from '../models/Plan.js';
import { PlanStep } from '../models/PlanStep.js';
import { StructuralValidator } from '../validators/StructuralValidator.js';
import { DependencyValidator } from '../validators/DependencyValidator.js';
import { SemanticValidator } from '../validators/SemanticValidator.js';
import { CompletenessValidator } from '../validators/CompletenessValidator.js';
import { EventEmitter } from 'events';

class EnhancedPlanValidator extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = {
      strictMode: false,
      maxSteps: 100,
      maxDependencyDepth: 10,
      requireSuccessCriteria: true,
      validateSemantics: true,
      ...config
    };

    // Initialize validation pipeline
    this.validationPipeline = [
      new StructuralValidator({ strictMode: this.config.strictMode }),
      new DependencyValidator({ maxDependencyDepth: this.config.maxDependencyDepth }),
      new SemanticValidator({ validateLogicalFlow: this.config.validateSemantics }),
      new CompletenessValidator({ requireSuccessCriteria: this.config.requireSuccessCriteria })
    ];

    // Domain-specific validators
    this.domainValidators = new Map();
  }

  /**
   * Validate a plan using the validation pipeline
   * 
   * @param {Plan} plan - The plan to validate
   * @returns {Object} Comprehensive validation result
   */
  async validate(plan) {
    this.emit('validation:start', plan);

    const validationResult = {
      isValid: true,
      errors: [],
      warnings: [],
      suggestions: [],
      score: 100,
      details: {},
      executionReadiness: null
    };

    try {
      // Run through validation pipeline
      for (const validator of this.validationPipeline) {
        const validatorName = validator.constructor.name;
        this.emit('validator:start', validatorName);

        const result = await validator.validate(plan);
        this._mergeResults(validationResult, result, validatorName);

        this.emit('validator:complete', validatorName, result);
      }

      // Apply domain-specific validation if available
      if (plan.domain && this.domainValidators.has(plan.domain)) {
        const domainValidator = this.domainValidators.get(plan.domain);
        const domainResult = await domainValidator.validate(plan);
        this._mergeResults(validationResult, domainResult, `${plan.domain}Validator`);
      }

      // Calculate final score
      validationResult.score = this._calculateQualityScore(validationResult);

      // Determine if plan is valid
      validationResult.isValid = validationResult.errors.length === 0;

      // Add execution readiness assessment
      validationResult.executionReadiness = this._assessExecutionReadiness(validationResult);

    } catch (error) {
      this.emit('validation:error', error);
      validationResult.isValid = false;
      validationResult.errors.push({
        type: 'validation_error',
        message: `Validation failed: ${error.message}`,
        severity: 'critical'
      });
    }

    this.emit('validation:complete', validationResult);
    return validationResult;
  }

  /**
   * Register a domain-specific validator
   * 
   * @param {string} domain - Domain name (e.g., 'code', 'test', 'architecture')
   * @param {Object} validator - Validator instance with validate method
   */
  registerDomainValidator(domain, validator) {
    if (!validator || typeof validator.validate !== 'function') {
      throw new Error('Validator must have a validate method');
    }
    this.domainValidators.set(domain, validator);
    this.emit('validator:registered', domain);
  }

  /**
   * Add a custom validator to the pipeline
   * 
   * @param {Object} validator - Validator instance
   * @param {number} position - Position in pipeline (default: end)
   */
  addValidator(validator, position = -1) {
    if (!validator || typeof validator.validate !== 'function') {
      throw new Error('Validator must have a validate method');
    }

    if (position === -1) {
      this.validationPipeline.push(validator);
    } else {
      this.validationPipeline.splice(position, 0, validator);
    }
  }

  /**
   * Merge validation results from individual validators
   * @private
   */
  _mergeResults(target, source, validatorName) {
    // Merge errors
    if (source.errors && source.errors.length > 0) {
      target.errors.push(...source.errors.map(e => ({
        ...e,
        validator: validatorName
      })));
    }

    // Merge warnings
    if (source.warnings && source.warnings.length > 0) {
      target.warnings.push(...source.warnings.map(w => ({
        ...w,
        validator: validatorName
      })));
    }

    // Merge suggestions
    if (source.suggestions && source.suggestions.length > 0) {
      target.suggestions.push(...source.suggestions.map(s => ({
        ...s,
        validator: validatorName
      })));
    }

    // Store detailed results
    target.details[validatorName] = {
      errors: source.errors?.length || 0,
      warnings: source.warnings?.length || 0,
      suggestions: source.suggestions?.length || 0,
      customData: source.customData || {}
    };

    // Merge custom scores if present
    if (source.completenessScore !== undefined) {
      target.details[validatorName].completenessScore = source.completenessScore;
    }
  }

  /**
   * Calculate overall quality score based on validation results
   * @private
   */
  _calculateQualityScore(validationResult) {
    let score = 100;

    // Base deductions
    const weights = {
      error: -20,
      warning: -5,
      suggestion: -1
    };

    score -= validationResult.errors.length * weights.error;
    score -= validationResult.warnings.length * weights.warning;
    score -= validationResult.suggestions.length * weights.suggestion;

    // Factor in completeness score if available
    const completenessScore = validationResult.details.CompletenessValidator?.completenessScore;
    if (completenessScore !== undefined) {
      // Weight completeness as 30% of total score
      score = (score * 0.7) + (completenessScore * 0.3);
    }

    // Ensure score is within bounds
    return Math.max(0, Math.min(100, Math.round(score)));
  }

  /**
   * Assess execution readiness based on validation results
   * @private
   */
  _assessExecutionReadiness(validationResult) {
    const readiness = {
      ready: false,
      confidence: 0,
      blockers: [],
      recommendations: []
    };

    // Check for critical blockers
    const criticalErrors = validationResult.errors.filter(e => 
      e.type === 'circular_dependency' || 
      e.type === 'missing_required_field' ||
      e.type === 'invalid_dependency'
    );

    if (criticalErrors.length > 0) {
      readiness.blockers.push(...criticalErrors.map(e => e.message));
    }

    // Calculate confidence based on score and issues
    if (validationResult.score >= 80 && criticalErrors.length === 0) {
      readiness.ready = true;
      readiness.confidence = validationResult.score;
    } else if (validationResult.score >= 60 && criticalErrors.length === 0) {
      readiness.ready = true;
      readiness.confidence = validationResult.score;
      readiness.recommendations.push('Plan has some warnings that should be addressed');
    } else {
      readiness.ready = false;
      readiness.confidence = validationResult.score;
      readiness.recommendations.push('Plan requires significant improvements before execution');
    }

    // Add specific recommendations based on issues
    if (validationResult.warnings.some(w => w.type === 'missing_tests')) {
      readiness.recommendations.push('Consider adding test coverage');
    }

    if (validationResult.warnings.some(w => w.type === 'missing_rollback')) {
      readiness.recommendations.push('Add rollback provisions for critical steps');
    }

    return readiness;
  }

  /**
   * Generate validation report
   * 
   * @param {Object} validationResult - Validation result object
   * @returns {string} Formatted validation report
   */
  generateReport(validationResult) {
    const lines = [];
    
    lines.push('# Plan Validation Report');
    lines.push('');
    lines.push(`**Overall Score:** ${validationResult.score}/100`);
    lines.push(`**Status:** ${validationResult.isValid ? '✅ Valid' : '❌ Invalid'}`);
    lines.push(`**Execution Ready:** ${validationResult.executionReadiness.ready ? 'Yes' : 'No'}`);
    lines.push('');

    // Summary
    lines.push('## Summary');
    lines.push(`- Errors: ${validationResult.errors.length}`);
    lines.push(`- Warnings: ${validationResult.warnings.length}`);
    lines.push(`- Suggestions: ${validationResult.suggestions.length}`);
    lines.push('');

    // Errors
    if (validationResult.errors.length > 0) {
      lines.push('## Errors');
      for (const error of validationResult.errors) {
        lines.push(`- **[${error.type}]** ${error.message} (${error.validator})`);
      }
      lines.push('');
    }

    // Warnings
    if (validationResult.warnings.length > 0) {
      lines.push('## Warnings');
      for (const warning of validationResult.warnings) {
        lines.push(`- **[${warning.type}]** ${warning.message} (${warning.validator})`);
      }
      lines.push('');
    }

    // Suggestions
    if (validationResult.suggestions.length > 0) {
      lines.push('## Suggestions');
      for (const suggestion of validationResult.suggestions) {
        lines.push(`- ${suggestion.message}`);
      }
      lines.push('');
    }

    // Execution Readiness
    lines.push('## Execution Readiness');
    lines.push(`**Confidence:** ${validationResult.executionReadiness.confidence}%`);
    
    if (validationResult.executionReadiness.blockers.length > 0) {
      lines.push('### Blockers');
      for (const blocker of validationResult.executionReadiness.blockers) {
        lines.push(`- ${blocker}`);
      }
    }

    if (validationResult.executionReadiness.recommendations.length > 0) {
      lines.push('### Recommendations');
      for (const rec of validationResult.executionReadiness.recommendations) {
        lines.push(`- ${rec}`);
      }
    }

    return lines.join('\n');
  }

  /**
   * Validate a plan and throw if invalid
   * 
   * @param {Plan} plan - The plan to validate
   * @throws {Error} If plan is invalid
   */
  async validateOrThrow(plan) {
    const result = await this.validate(plan);
    
    if (!result.isValid) {
      const errorMessages = result.errors.map(e => e.message).join('; ');
      throw new Error(`Plan validation failed: ${errorMessages}`);
    }

    return result;
  }

  /**
   * Quick validation check without full pipeline
   * 
   * @param {Plan} plan - The plan to validate
   * @returns {boolean} True if plan passes basic checks
   */
  quickValidate(plan) {
    try {
      // Basic checks only
      if (!plan || !plan.id || !plan.name || !plan.steps) {
        return false;
      }

      if (!Array.isArray(plan.steps) || plan.steps.length === 0) {
        return false;
      }

      // Check for duplicate step IDs
      const stepIds = new Set();
      for (const step of plan.steps) {
        if (!step.id || stepIds.has(step.id)) {
          return false;
        }
        stepIds.add(step.id);
      }

      return true;
    } catch {
      return false;
    }
  }
}

export { EnhancedPlanValidator };