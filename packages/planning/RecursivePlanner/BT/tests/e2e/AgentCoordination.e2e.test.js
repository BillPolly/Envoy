/**
 * End-to-End test for AI agent coordination using BT
 * Tests scenarios where multiple AI agents collaborate through BT coordination
 */

import { describe, test, expect, beforeEach, jest } from '@jest/globals';
import { BehaviorTreeExecutor } from '../../src/core/BehaviorTreeExecutor.js';
import { BehaviorTreeTool } from '../../src/integration/BehaviorTreeTool.js';
import { PlanToBTConverter } from '../../src/integration/PlanToBTConverter.js';
import { NodeStatus } from '../../src/core/BehaviorTreeNode.js';

// Mock AI Agent implementations
class MockAIAgent {
  constructor(name, specialization) {
    this.name = name;
    this.specialization = specialization;
    this.memory = new Map();
    this.executionCount = 0;
  }

  async process(task, context = {}) {
    this.executionCount++;
    
    // Simulate different agent behaviors based on specialization
    switch (this.specialization) {
      case 'planner':
        return this.plan(task, context);
      case 'coder':
        return this.code(task, context);
      case 'reviewer':
        return this.review(task, context);
      case 'tester':
        return this.test(task, context);
      default:
        return { success: true, data: { message: `${this.name} processed task` } };
    }
  }

  async plan(task, context) {
    // Simulate planning agent
    const steps = [];
    if (task.includes('implement')) {
      steps.push('design', 'code', 'test', 'deploy');
    } else if (task.includes('refactor')) {
      steps.push('analyze', 'refactor', 'test');
    } else {
      steps.push('analyze', 'execute');
    }

    return {
      success: true,
      data: {
        agent: this.name,
        plan: steps,
        estimatedTime: steps.length * 100,
        dependencies: context.dependencies || []
      }
    };
  }

  async code(task, context) {
    // Simulate coding agent
    const language = context.language || 'javascript';
    const framework = context.framework || 'none';
    
    return {
      success: true,
      data: {
        agent: this.name,
        code: `// Generated by ${this.name}\n// Task: ${task}\n// Language: ${language}\nfunction execute() { return true; }`,
        language,
        framework,
        loc: 75 // Fixed value for predictable tests
      }
    };
  }

  async review(task, context) {
    // Simulate review agent - deterministic for testing
    const issues = context.strictMode ? 0 : 1; // No issues in strict mode
    const approved = issues === 0;
    
    return {
      success: approved,
      data: {
        agent: this.name,
        approved,
        issues,
        suggestions: issues > 0 ? ['Add tests', 'Improve naming'] : [],
        reviewedAt: Date.now()
      }
    };
  }

  async test(task, context) {
    // Simulate testing agent - deterministic for testing
    const testCount = 10;
    const passed = 10; // All tests pass for predictable results
    
    return {
      success: passed === testCount,
      data: {
        agent: this.name,
        tests: testCount,
        passed,
        failed: testCount - passed,
        coverage: 85 // Fixed coverage value
      }
    };
  }

  rememberContext(key, value) {
    this.memory.set(key, value);
  }

  recallContext(key) {
    return this.memory.get(key);
  }

  getExecutionCount() {
    return this.executionCount;
  }

  reset() {
    this.memory.clear();
    this.executionCount = 0;
  }
}

// Mock tool implementations for AI agents
class AIAgentTools {
  constructor() {
    this.agents = new Map();
    this.conversations = [];
    this.sharedContext = new Map();
  }

  registerAgent(agent) {
    this.agents.set(agent.name, agent);
  }

  createAgentTool(agentName) {
    const self = this;
    return {
      name: `agent_${agentName}`,
      async execute(params) {
        const agent = self.agents.get(agentName);
        if (!agent) {
          return { success: false, data: { error: `Agent ${agentName} not found` } };
        }

        const { task, context = {} } = params;
        
        // Add shared context
        const enrichedContext = {
          ...context,
          sharedContext: Object.fromEntries(self.sharedContext),
          previousAgents: self.conversations.map(c => c.agent)
        };

        const result = await agent.process(task, enrichedContext);
        
        // Record conversation
        self.conversations.push({
          agent: agentName,
          task,
          result: result.data,
          timestamp: Date.now()
        });

        // Update shared context if agent provides updates
        if (result.data.contextUpdates) {
          for (const [key, value] of Object.entries(result.data.contextUpdates)) {
            self.sharedContext.set(key, value);
          }
        }

        return result;
      },
      getMetadata() {
        return {
          name: `agent_${agentName}`,
          description: `AI agent: ${agentName}`,
          input: {
            task: { type: 'string', required: true },
            context: { type: 'object', required: false }
          }
        };
      }
    };
  }

  createCoordinatorTool() {
    const self = this;
    return {
      name: 'coordinator',
      async execute(params) {
        const { agents = [], task, strategy = 'sequential' } = params;
        
        const results = [];
        
        if (strategy === 'sequential') {
          for (const agentName of agents) {
            const agent = self.agents.get(agentName);
            if (agent) {
              const result = await agent.process(task, { previousResults: results });
              results.push({ agent: agentName, result: result.data });
            }
          }
        } else if (strategy === 'parallel') {
          const promises = agents.map(agentName => {
            const agent = self.agents.get(agentName);
            return agent ? agent.process(task, {}) : Promise.resolve(null);
          });
          
          const parallelResults = await Promise.all(promises);
          parallelResults.forEach((result, i) => {
            if (result) {
              results.push({ agent: agents[i], result: result.data });
            }
          });
        }

        return {
          success: results.length > 0,
          data: {
            strategy,
            results,
            agentsInvolved: agents,
            completedAt: Date.now()
          }
        };
      },
      getMetadata() {
        return {
          name: 'coordinator',
          description: 'Coordinates multiple AI agents',
          input: {
            agents: { type: 'array', required: true },
            task: { type: 'string', required: true },
            strategy: { type: 'string', required: false }
          }
        };
      }
    };
  }

  getConversationHistory() {
    return this.conversations;
  }

  getSharedContext() {
    return Object.fromEntries(this.sharedContext);
  }

  reset() {
    this.conversations = [];
    this.sharedContext.clear();
    for (const agent of this.agents.values()) {
      agent.reset();
    }
  }
}

// Mock ToolRegistry
class MockToolRegistry {
  constructor() {
    this.tools = new Map();
  }

  async getTool(toolName) {
    return this.tools.get(toolName);
  }

  registerTool(name, tool) {
    this.tools.set(name, tool);
  }
}

describe('Agent Coordination E2E Tests', () => {
  let toolRegistry;
  let executor;
  let agentTools;
  let plannerAgent;
  let coderAgent;
  let reviewerAgent;
  let testerAgent;

  beforeEach(() => {
    toolRegistry = new MockToolRegistry();
    executor = new BehaviorTreeExecutor(toolRegistry);
    agentTools = new AIAgentTools();

    // Create specialized agents
    plannerAgent = new MockAIAgent('PlannerBot', 'planner');
    coderAgent = new MockAIAgent('CoderBot', 'coder');
    reviewerAgent = new MockAIAgent('ReviewerBot', 'reviewer');
    testerAgent = new MockAIAgent('TesterBot', 'tester');

    // Register agents
    agentTools.registerAgent(plannerAgent);
    agentTools.registerAgent(coderAgent);
    agentTools.registerAgent(reviewerAgent);
    agentTools.registerAgent(testerAgent);

    // Register tools
    toolRegistry.registerTool('agent_PlannerBot', agentTools.createAgentTool('PlannerBot'));
    toolRegistry.registerTool('agent_CoderBot', agentTools.createAgentTool('CoderBot'));
    toolRegistry.registerTool('agent_ReviewerBot', agentTools.createAgentTool('ReviewerBot'));
    toolRegistry.registerTool('agent_TesterBot', agentTools.createAgentTool('TesterBot'));
    toolRegistry.registerTool('coordinator', agentTools.createCoordinatorTool());
  });

  describe('Multi-Agent Development Workflow', () => {
    test('should coordinate agents for complete development cycle', async () => {
      const developmentWorkflow = {
        type: 'sequence',
        description: 'Multi-agent development workflow',
        children: [
          {
            type: 'action',
            id: 'planning',
            tool: 'agent_PlannerBot',
            params: {
              task: 'implement user authentication system',
              context: { requirements: ['OAuth', 'JWT', 'MFA'] }
            }
          },
          {
            type: 'action',
            id: 'coding',
            tool: 'agent_CoderBot',
            params: {
              task: 'implement based on plan: {{planning.data.plan}}',
              context: { 
                language: 'typescript',
                framework: 'express'
              }
            }
          },
          {
            type: 'action',
            id: 'review',
            tool: 'agent_ReviewerBot',
            params: {
              task: 'review code: {{coding.data.code}}',
              context: { strictMode: true } // This ensures review passes
            }
          },
          {
            type: 'selector',
            description: 'Handle review outcome',
            children: [
              {
                type: 'sequence',
                description: 'If approved, test',
                children: [
                  {
                    type: 'action',
                    id: 'testing',
                    tool: 'agent_TesterBot',
                    params: {
                      task: 'test implementation',
                      context: { coverage: 'full' }
                    }
                  }
                ]
              },
              {
                type: 'sequence',
                description: 'If not approved, revise',
                children: [
                  {
                    type: 'action',
                    id: 'revision',
                    tool: 'agent_CoderBot',
                    params: {
                      task: 'revise based on feedback: {{review.data.suggestions}}',
                      context: { revision: true }
                    }
                  },
                  {
                    type: 'action',
                    id: 'retest',
                    tool: 'agent_TesterBot',
                    params: {
                      task: 'test revised implementation'
                    }
                  }
                ]
              }
            ]
          }
        ]
      };

      const result = await executor.executeTree(developmentWorkflow, {});

      expect(result.success).toBe(true);
      expect(result.status).toBe(NodeStatus.SUCCESS);

      // Verify agent execution
      expect(plannerAgent.getExecutionCount()).toBeGreaterThan(0);
      expect(coderAgent.getExecutionCount()).toBeGreaterThan(0);
      expect(testerAgent.getExecutionCount()).toBeGreaterThan(0);

      // Verify conversation history
      const history = agentTools.getConversationHistory();
      expect(history.length).toBeGreaterThan(0);
      expect(history[0].agent).toBe('PlannerBot');
      expect(history.some(h => h.agent === 'CoderBot')).toBe(true);
    });

    test('should handle parallel agent coordination', async () => {
      const parallelWorkflow = {
        type: 'sequence',
        children: [
          {
            type: 'action',
            id: 'coordinate',
            tool: 'coordinator',
            params: {
              agents: ['PlannerBot', 'CoderBot', 'ReviewerBot'],
              task: 'analyze project requirements',
              strategy: 'parallel'
            }
          },
          {
            type: 'action',
            id: 'consolidate',
            tool: 'agent_PlannerBot',
            params: {
              task: 'consolidate results from parallel analysis',
              context: { results: '{{coordinate.data.results}}' }
            }
          }
        ]
      };

      const result = await executor.executeTree(parallelWorkflow, {});

      expect(result.success).toBe(true);

      // Verify parallel execution
      const coordinateResult = result.nodeResults?.coordinate || result.context;
      expect(coordinateResult).toBeDefined();
      
      // All agents should have executed
      expect(plannerAgent.getExecutionCount()).toBe(2); // Once in parallel, once to consolidate
      expect(coderAgent.getExecutionCount()).toBe(1);
      expect(reviewerAgent.getExecutionCount()).toBe(1);
    });
  });

  describe('Agent Conversation and Context Sharing', () => {
    test('should maintain conversation context across agents', async () => {
      const contextAwareWorkflow = {
        type: 'sequence',
        children: [
          {
            type: 'action',
            id: 'initial',
            tool: 'agent_PlannerBot',
            params: {
              task: 'create project structure',
              context: { 
                project: 'AIAssistant',
                contextUpdates: { projectName: 'AIAssistant' }
              }
            }
          },
          {
            type: 'action',
            id: 'implement',
            tool: 'agent_CoderBot',
            params: {
              task: 'implement core module',
              context: { 
                useSharedContext: true,
                contextUpdates: { moduleName: 'CoreModule' }
              }
            }
          },
          {
            type: 'action',
            id: 'document',
            tool: 'agent_ReviewerBot',
            params: {
              task: 'create documentation based on shared context',
              context: { includeAll: true, strictMode: true }
            }
          }
        ]
      };

      const result = await executor.executeTree(contextAwareWorkflow, {});

      expect(result.success).toBe(true);

      // Verify context sharing
      const history = agentTools.getConversationHistory();
      expect(history.length).toBe(3);
      
      // Verify agents were called in sequence
      expect(history[0].agent).toBe('PlannerBot');
      expect(history[1].agent).toBe('CoderBot');
      expect(history[2].agent).toBe('ReviewerBot');
      
      // Verify each conversation was recorded
      expect(history[0].task).toContain('create project structure');
      expect(history[1].task).toContain('implement core module');
      expect(history[2].task).toContain('create documentation');
    });

    test('should handle agent memory and learning', async () => {
      // First workflow - agents learn
      const learningWorkflow1 = {
        type: 'sequence',
        children: [
          {
            type: 'action',
            tool: 'agent_PlannerBot',
            params: {
              task: 'learn project patterns',
              context: { pattern: 'MVC' }
            }
          }
        ]
      };

      await executor.executeTree(learningWorkflow1, {});
      
      // Agent remembers context
      plannerAgent.rememberContext('pattern', 'MVC');

      // Second workflow - agents recall
      const learningWorkflow2 = {
        type: 'sequence',
        children: [
          {
            type: 'action',
            tool: 'agent_PlannerBot',
            params: {
              task: 'apply learned patterns',
              context: {}
            }
          }
        ]
      };

      const result = await executor.executeTree(learningWorkflow2, {});

      expect(result.success).toBe(true);
      expect(plannerAgent.recallContext('pattern')).toBe('MVC');
      expect(plannerAgent.getExecutionCount()).toBe(2);
    });
  });

  describe('Complex Agent Coordination Patterns', () => {
    test('should handle voting pattern among agents', async () => {
      const votingWorkflow = {
        type: 'selector',
        description: 'Agent voting on best approach',
        children: [
          {
            type: 'sequence',
            description: 'Majority approval path',
            children: [
              {
                type: 'action',
                id: 'vote1',
                tool: 'agent_PlannerBot',
                params: { task: 'vote on approach A' }
              },
              {
                type: 'action',
                id: 'vote2',
                tool: 'agent_ReviewerBot',
                params: { task: 'vote on approach A' }
              },
              {
                type: 'action',
                id: 'implement',
                tool: 'agent_CoderBot',
                params: { task: 'implement approach A' }
              }
            ]
          },
          {
            type: 'action',
            id: 'fallback',
            tool: 'agent_CoderBot',
            params: { task: 'implement default approach' }
          }
        ]
      };

      const result = await executor.executeTree(votingWorkflow, {});

      expect(result.success).toBe(true);
      
      // At least one path should execute
      const history = agentTools.getConversationHistory();
      expect(history.length).toBeGreaterThan(0);
    });

    test('should handle agent delegation chains', async () => {
      const delegationWorkflow = {
        type: 'sequence',
        children: [
          {
            type: 'action',
            id: 'delegate1',
            tool: 'agent_PlannerBot',
            params: {
              task: 'plan complex system',
              context: {
                delegateTo: 'CoderBot',
                subtask: 'implement critical component'
              }
            }
          },
          {
            type: 'selector',
            description: 'Delegation decision',
            children: [
              {
                type: 'action',
                id: 'delegated',
                tool: 'agent_CoderBot',
                params: {
                  task: '{{delegate1.data.subtask}}',
                  context: { isDelegated: true }
                }
              },
              {
                type: 'action',
                id: 'self',
                tool: 'agent_PlannerBot',
                params: {
                  task: 'handle task directly',
                  context: { noDelegation: true }
                }
              }
            ]
          }
        ]
      };

      const result = await executor.executeTree(delegationWorkflow, {});

      expect(result.success).toBe(true);
      
      // Verify delegation occurred
      const history = agentTools.getConversationHistory();
      expect(history.some(h => h.agent === 'PlannerBot')).toBe(true);
    });

    test('should handle consensus-building among agents', async () => {
      const consensusWorkflow = {
        type: 'sequence',
        children: [
          {
            type: 'action',
            id: 'proposal',
            tool: 'agent_PlannerBot',
            params: {
              task: 'propose architecture design',
              context: { design: 'microservices' }
            }
          },
          {
            type: 'action',
            id: 'review1',
            tool: 'agent_ReviewerBot',
            params: {
              task: 'review proposal: {{proposal.data}}',
              context: { criteria: 'scalability', strictMode: true }
            }
          },
          {
            type: 'action',
            id: 'review2',
            tool: 'agent_TesterBot',
            params: {
              task: 'test feasibility of proposal',
              context: { criteria: 'testability' }
            }
          },
          {
            type: 'selector',
            description: 'Consensus decision',
            children: [
              {
                type: 'action',
                id: 'approved',
                tool: 'agent_CoderBot',
                params: {
                  task: 'implement approved design',
                  context: { consensus: true }
                }
              },
              {
                type: 'sequence',
                description: 'Revision needed',
                children: [
                  {
                    type: 'action',
                    id: 'revise',
                    tool: 'agent_PlannerBot',
                    params: {
                      task: 'revise proposal based on feedback',
                      context: { 
                        feedback: '{{review1.data.suggestions}}',
                        testResults: '{{review2.data}}'
                      }
                    }
                  },
                  {
                    type: 'action',
                    id: 'implement-revised',
                    tool: 'agent_CoderBot',
                    params: {
                      task: 'implement revised design'
                    }
                  }
                ]
              }
            ]
          }
        ]
      };

      const result = await executor.executeTree(consensusWorkflow, {});

      expect(result.success).toBe(true);
      
      // All review agents should have participated
      expect(reviewerAgent.getExecutionCount()).toBeGreaterThan(0);
      expect(testerAgent.getExecutionCount()).toBeGreaterThan(0);
      
      // Final implementation should occur
      expect(coderAgent.getExecutionCount()).toBeGreaterThan(0);
    });
  });

  describe('Error Recovery and Agent Failover', () => {
    test('should handle agent failures with failover', async () => {
      // Make primary agent fail
      const failingAgent = new MockAIAgent('FailingBot', 'planner');
      failingAgent.process = async () => {
        throw new Error('Agent crashed');
      };
      
      agentTools.registerAgent(failingAgent);
      toolRegistry.registerTool('agent_FailingBot', agentTools.createAgentTool('FailingBot'));

      const failoverWorkflow = {
        type: 'selector',
        description: 'Agent failover pattern',
        children: [
          {
            type: 'action',
            id: 'primary',
            tool: 'agent_FailingBot',
            params: { task: 'primary task' }
          },
          {
            type: 'action',
            id: 'backup1',
            tool: 'agent_PlannerBot',
            params: { task: 'handle as backup' }
          },
          {
            type: 'action',
            id: 'backup2',
            tool: 'agent_CoderBot',
            params: { task: 'final fallback' }
          }
        ]
      };

      const result = await executor.executeTree(failoverWorkflow, {});

      expect(result.success).toBe(true);
      
      // Verify failover occurred
      const history = agentTools.getConversationHistory();
      expect(history.some(h => h.agent === 'PlannerBot')).toBe(true);
      expect(history.every(h => h.agent !== 'FailingBot')).toBe(true);
    });

    test('should implement circuit breaker pattern for agents', async () => {
      let failureCount = 0;
      const unreliableAgent = new MockAIAgent('UnreliableBot', 'tester');
      unreliableAgent.process = async () => {
        failureCount++;
        if (failureCount < 3) {
          throw new Error('Temporary failure');
        }
        return { success: true, data: { recovered: true } };
      };

      agentTools.registerAgent(unreliableAgent);
      toolRegistry.registerTool('agent_UnreliableBot', agentTools.createAgentTool('UnreliableBot'));

      const circuitBreakerWorkflow = {
        type: 'selector',
        description: 'Circuit breaker pattern',
        children: [
          {
            type: 'action',
            id: 'attempt1',
            tool: 'agent_UnreliableBot',
            params: { task: 'attempt 1' }
          },
          {
            type: 'action',
            id: 'attempt2',
            tool: 'agent_UnreliableBot',
            params: { task: 'attempt 2' }
          },
          {
            type: 'action',
            id: 'attempt3',
            tool: 'agent_UnreliableBot',
            params: { task: 'attempt 3' }
          },
          {
            type: 'action',
            id: 'circuit-open',
            tool: 'agent_PlannerBot',
            params: { task: 'circuit breaker opened - use alternative' }
          }
        ]
      };

      const result = await executor.executeTree(circuitBreakerWorkflow, {});

      expect(result.success).toBe(true);
      
      // Circuit breaker should eventually succeed or failover
      const history = agentTools.getConversationHistory();
      expect(history.length).toBeGreaterThan(0);
    });
  });
});