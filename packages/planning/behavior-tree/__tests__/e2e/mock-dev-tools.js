/**
 * Mock development tools for testing the ClassGeneratorWorkflow
 * Simulates code generation, testing, and fixing processes
 */

export class MockDevTools {
  constructor() {
    this.fileSystem = new Map();
    this.executionLog = [];
    this.testFailureScenarios = new Map();
    this.fixAttempts = new Map(); // Track fix attempts per class
  }

  /**
   * Create a class generator tool
   * Generates JavaScript class code from specifications
   */
  createClassGenerator() {
    const self = this;
    return {
      name: 'classGenerator',
      async execute(params) {
        self.executionLog.push({ tool: 'classGenerator', params });
        
        const { className, description, methods = [] } = params;
        
        if (!className) {
          return { 
            success: false, 
            data: { error: 'className is required' } 
          };
        }

        // Generate class code
        const methodImplementations = methods.map(method => {
          // Intentionally create some buggy implementations for testing
          if (self.testFailureScenarios.has(`${className}.${method}`)) {
            const scenario = self.testFailureScenarios.get(`${className}.${method}`);
            return `  ${method}(${scenario.params || ''}) {
    ${scenario.buggyCode || 'throw new Error("Not implemented");'}
  }`;
          }
          
          // Default correct implementation
          return `  ${method}(${self.getMethodParams(method)}) {
    // Implementation for ${method}
    ${self.getMethodBody(method)}
  }`;
        }).join('\n\n');

        const code = `/**
 * ${description || `Class ${className}`}
 * Generated by ClassGeneratorWorkflow
 */
class ${className} {
  constructor() {
    this.initialized = true;
    this.data = {};
  }

${methodImplementations}
}

module.exports = ${className};`;

        // Store in filesystem
        const filePath = `src/${className}.js`;
        self.fileSystem.set(filePath, code);

        return {
          success: true,
          data: {
            code,
            className,
            filePath,
            methods,
            timestamp: Date.now()
          }
        };
      },
      getMetadata() {
        return {
          name: 'classGenerator',
          description: 'Generates class code from specifications',
          input: {
            className: { type: 'string', required: true },
            description: { type: 'string', required: false },
            methods: { type: 'array', required: true }
          }
        };
      }
    };
  }

  /**
   * Create a test generator tool
   * Generates test suite for a class
   */
  createTestGenerator() {
    const self = this;
    return {
      name: 'testGenerator',
      async execute(params) {
        self.executionLog.push({ tool: 'testGenerator', params });
        
        const { className, classCode, methods = [] } = params;
        
        if (!className || !classCode) {
          return { 
            success: false, 
            data: { error: 'className and classCode are required' } 
          };
        }

        // Generate test cases for each method
        const testCases = methods.map(method => {
          return `  test('should execute ${method} correctly', () => {
    const instance = new ${className}();
    ${self.getTestAssertion(method)}
  });`;
        }).join('\n\n');

        const testCode = `const ${className} = require('./src/${className}');

describe('${className}', () => {
  test('should create instance', () => {
    const instance = new ${className}();
    expect(instance).toBeDefined();
    expect(instance.initialized).toBe(true);
  });

${testCases}
});`;

        // Store test file
        const testPath = `tests/${className}.test.js`;
        self.fileSystem.set(testPath, testCode);

        return {
          success: true,
          data: {
            testCode,
            testPath,
            className,
            testCount: methods.length + 1,
            timestamp: Date.now()
          }
        };
      },
      getMetadata() {
        return {
          name: 'testGenerator',
          description: 'Generates test suite for a class',
          input: {
            className: { type: 'string', required: true },
            classCode: { type: 'string', required: true },
            methods: { type: 'array', required: false }
          }
        };
      }
    };
  }

  /**
   * Create a test runner tool
   * Executes tests and returns results
   */
  createTestRunner() {
    const self = this;
    return {
      name: 'testRunner',
      async execute(params) {
        self.executionLog.push({ tool: 'testRunner', params });
        
        const { classCode, testCode, className } = params;
        
        if (!testCode) {
          return { 
            success: false, 
            data: { error: 'testCode is required' } 
          };
        }

        // Simulate test execution
        const failures = [];
        
        // Check for intentional bugs
        for (const [key, scenario] of self.testFailureScenarios) {
          if (key.startsWith(className)) {
            failures.push({
              test: `should execute ${key.split('.')[1]} correctly`,
              error: scenario.errorMessage || 'Method not implemented correctly',
              expected: scenario.expected,
              received: scenario.received
            });
          }
        }

        const totalTests = (params.methods?.length || 3) + 1;
        const passed = totalTests - failures.length;

        return {
          success: failures.length === 0,
          data: {
            totalTests,
            passed,
            failed: failures.length,
            failures,
            coverage: failures.length === 0 ? 100 : Math.floor((passed / totalTests) * 100),
            timestamp: Date.now()
          }
        };
      },
      getMetadata() {
        return {
          name: 'testRunner',
          description: 'Executes tests and returns results',
          input: {
            classCode: { type: 'string', required: false },
            testCode: { type: 'string', required: true },
            className: { type: 'string', required: false },
            methods: { type: 'array', required: false }
          }
        };
      }
    };
  }

  /**
   * Create a code fixer tool
   * Analyzes test failures and generates fixes
   */
  createCodeFixer() {
    const self = this;
    return {
      name: 'codeFixer',
      async execute(params) {
        self.executionLog.push({ tool: 'codeFixer', params });
        
        const { classCode, testResults, className } = params;
        
        if (!classCode || !testResults) {
          return { 
            success: false, 
            data: { error: 'classCode and testResults are required' } 
          };
        }

        const fixes = [];
        let fixedCode = classCode;

        // Analyze failures and generate fixes
        if (testResults.failures && testResults.failures.length > 0) {
          for (const failure of testResults.failures) {
            const methodName = failure.test.match(/should execute (\w+) correctly/)?.[1];
            if (methodName) {
              // Generate fix for the method
              const bugKey = `${className}.${methodName}`;
              const scenario = self.testFailureScenarios.get(bugKey);
              
              if (scenario && scenario.fixedCode) {
                // Replace buggy implementation with fixed one
                const buggyPattern = new RegExp(
                  `${methodName}\\([^)]*\\)\\s*{[^}]+}`,
                  's'
                );
                const fixedMethod = `${methodName}(${scenario.params || ''}) {
    ${scenario.fixedCode}
  }`;
                
                fixedCode = fixedCode.replace(buggyPattern, fixedMethod);
                
                fixes.push({
                  method: methodName,
                  issue: failure.error,
                  fix: 'Corrected implementation'
                });

                // Track fix attempt
                const attempts = self.fixAttempts.get(bugKey) || 0;
                self.fixAttempts.set(bugKey, attempts + 1);
                
                // Remove the failure scenario after fixing (simulating successful fix)
                if (attempts >= 0) { // Fix on first attempt for predictable tests
                  self.testFailureScenarios.delete(bugKey);
                }
              }
            }
          }
        }

        // Update filesystem with fixed code
        if (fixes.length > 0) {
          const filePath = `src/${className}.js`;
          self.fileSystem.set(filePath, fixedCode);
        }

        return {
          success: true,
          data: {
            fixes,
            fixedCode,
            fixCount: fixes.length,
            timestamp: Date.now()
          }
        };
      },
      getMetadata() {
        return {
          name: 'codeFixer',
          description: 'Analyzes test failures and fixes code',
          input: {
            classCode: { type: 'string', required: true },
            testResults: { type: 'object', required: true },
            className: { type: 'string', required: false }
          }
        };
      }
    };
  }

  /**
   * Create a success validator tool
   * Checks if tests passed and returns success/failure
   */
  createSuccessValidator() {
    const self = this;
    return {
      name: 'successValidator',
      async execute(params) {
        self.executionLog.push({ tool: 'successValidator', params });
        
        const { testResults } = params;
        
        if (!testResults) {
          return { 
            success: false, 
            data: { error: 'testResults are required' } 
          };
        }

        const allPassed = testResults.failed === 0 || testResults.failures?.length === 0;

        if (allPassed) {
          return {
            success: true,
            data: {
              message: 'All tests passed',
              testsPassed: testResults.passed || testResults.totalTests,
              coverage: testResults.coverage
            }
          };
        } else {
          return {
            success: false,
            data: {
              error: 'Tests failed',
              failureCount: testResults.failed || testResults.failures?.length,
              failures: testResults.failures
            }
          };
        }
      },
      getMetadata() {
        return {
          name: 'successValidator',
          description: 'Validates test results',
          input: {
            testResults: { type: 'object', required: true }
          }
        };
      }
    };
  }

  // Helper methods
  getMethodParams(method) {
    // Generate appropriate parameters based on method name
    if (method.includes('add') || method.includes('create')) return 'data';
    if (method.includes('get') || method.includes('find')) return 'id';
    if (method.includes('update')) return 'id, data';
    if (method.includes('delete') || method.includes('remove')) return 'id';
    return '';
  }

  getMethodBody(method) {
    // Generate appropriate method body
    if (method.includes('add') || method.includes('create')) {
      return `if (!data) throw new Error('Data required');
    const id = Date.now().toString();
    this.data[id] = data;
    return { id, ...data };`;
    }
    if (method.includes('get') || method.includes('find')) {
      return `if (!id) throw new Error('ID required');
    return this.data[id] || null;`;
    }
    if (method.includes('update')) {
      return `if (!id || !data) throw new Error('ID and data required');
    if (!this.data[id]) throw new Error('Not found');
    this.data[id] = { ...this.data[id], ...data };
    return this.data[id];`;
    }
    if (method.includes('delete') || method.includes('remove')) {
      return `if (!id) throw new Error('ID required');
    const deleted = this.data[id];
    delete this.data[id];
    return deleted;`;
    }
    if (method.includes('list') || method.includes('getAll')) {
      return 'return Object.values(this.data);';
    }
    return 'return true;';
  }

  getTestAssertion(method) {
    // Generate appropriate test assertion
    if (method.includes('add') || method.includes('create')) {
      return `const result = instance.${method}({ name: 'test' });
    expect(result).toBeDefined();
    expect(result.name).toBe('test');`;
    }
    if (method.includes('get') || method.includes('find')) {
      return `// First add some data
    const added = instance.${method.replace('get', 'add').replace('find', 'add')}({ name: 'test' });
    const result = instance.${method}(added.id);
    expect(result).toBeDefined();`;
    }
    if (method.includes('list') || method.includes('getAll')) {
      return `const result = instance.${method}();
    expect(Array.isArray(result)).toBe(true);`;
    }
    return `const result = instance.${method}();
    expect(result).toBeDefined();`;
  }

  // Test scenario management
  addTestFailureScenario(className, methodName, scenario) {
    this.testFailureScenarios.set(`${className}.${methodName}`, scenario);
  }

  clearTestFailureScenarios() {
    this.testFailureScenarios.clear();
    this.fixAttempts.clear();
  }

  // Utility methods
  getExecutionLog() {
    return this.executionLog;
  }

  clearExecutionLog() {
    this.executionLog = [];
  }

  getFileSystem() {
    return this.fileSystem;
  }

  getFile(path) {
    return this.fileSystem.get(path);
  }

  clearFileSystem() {
    this.fileSystem.clear();
  }
}