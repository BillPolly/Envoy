# Plan Executor Design Document - MVP

## Executive Summary

The Plan Executor is a standalone Legion module that executes plans generated by AI systems. It takes structured plans (in llm-planner format) and executes them by dynamically loading and invoking the appropriate Legion tools. The executor provides basic progress tracking and error handling while following Legion's module patterns.

## Problem Statement

Currently, there's a gap between plan generation (llm-planner) and execution. Aiur has its own execution logic, but we need a reusable, standardized execution engine that:

- Works with llm-planner's hierarchical plan format natively
- Dynamically loads only the Legion modules needed for each plan
- Provides progress events for monitoring
- Can be used as a Legion tool or standalone
- Separates execution logic from plan generation

## Design Philosophy

### Core Principles

**Separation of Concerns**: The executor only executes plans. It doesn't create, validate, or modify them.

**Dynamic Loading**: Only load the Legion modules required for a specific plan. This keeps the system lightweight and modular.

**Observable Execution**: Emit events during execution so external systems can monitor progress without tight coupling.

**Legion Integration**: Follow Legion's module patterns - extend Module, provide tools, use dependency injection.

### Key Design Decisions

**Synchronous Execution**: The plan execution tool blocks until completion, emitting progress events along the way. This follows Legion's pattern where tools return results, not promises.

**Native llm-planner Support**: Work directly with llm-planner's Plan/PlanStep/PlanAction structure rather than converting to a different format.

**Tool-Level Granularity**: Every atomic action in a plan must map to a Legion tool. The executor's sole job is to dynamically load these tools and invoke them with the correct parameters. No execution happens without Legion tools.

## Architecture Overview

The Plan Executor consists of four main components:

1. **PlanExecutorModule**: The Legion module wrapper that handles dependency injection
2. **PlanExecutorTool**: The tool interface that accepts plans and returns results  
3. **PlanExecutor**: The core execution engine that orchestrates plan execution
4. **ModuleLoader**: Handles dynamic loading of Legion modules based on plan requirements

### Data Flow

When a plan is executed:

1. The tool receives the plan and execution options
2. The executor analyzes the plan to identify required tools
3. The module loader dynamically loads the necessary Legion modules
4. The executor processes steps according to their dependencies
5. Progress events are emitted as steps complete
6. Results are collected and returned

## Component Design

### PlanExecutorModule

The PlanExecutorModule is a standard Legion module that depends on ResourceManager and ModuleFactory. Its job is simple:

- Accept the injected dependencies 
- Create a PlanExecutor instance with those dependencies
- Expose the PlanExecutorTool to consumers
- Forward execution events to module listeners

The module follows Legion's lazy initialization pattern - it doesn't do expensive work in the constructor.

### PlanExecutorTool

The PlanExecutorTool implements Legion's Tool interface. It accepts:

- **plan**: The llm-planner Plan object to execute (required)
- **options**: Execution options like parallel mode, timeout, retry count

The tool's execute method delegates to the PlanExecutor and formats results according to Legion conventions. This separation allows the core executor to be used independently if needed.

### PlanExecutor

The PlanExecutor is the orchestration engine. It handles:

**Plan Processing**: Takes the llm-planner Plan object and traverses its hierarchical structure, executing each step according to the hierarchy's control flow semantics.

**Module Loading**: Analyzes all actions in the plan to determine which Legion tools are required, then uses ModuleLoader to dynamically load the modules that provide those tools. This happens before any execution begins.

**Execution Orchestration**: Traverses the hierarchical plan structure, executing sub-steps and actions according to the plan's control flow logic while respecting dependencies.

**Progress Tracking**: Emits events as steps start, complete, or fail.

**Error Handling**: Implements basic retry logic and error collection.

### ModuleLoader

The ModuleLoader handles dynamic loading of Legion modules. It:

**Discovers Required Tools**: Scans the plan to build a list of all Legion tools that need to be loaded. Each action type in the plan corresponds to a specific Legion tool.

**Loads Modules**: For each required tool, finds and loads the appropriate Legion module using ModuleFactory.

**Caches Modules**: Keeps loaded modules in memory to avoid reloading for subsequent plans.

**Maps Tools**: Maintains a registry mapping tool names to their implementations.

The loader uses a simple strategy: it maintains a hardcoded mapping of common tool names to modules, and falls back to scanning available modules for unknown tools.

### Execution Context

The ExecutionContext is critical for hierarchical plan execution and maintains complete awareness of the executor's position and state:

**Hierarchical Position Tracking**: The context maintains the current execution path (e.g., "plan.step1.substep2.action3"), allowing the executor to know exactly where it is in the plan hierarchy at any moment.

**Navigation Stack**: An execution stack tracks the path from root to current position, enabling the executor to traverse up to parent contexts, down to child contexts, or across to sibling contexts as needed for control flow.

**Scoped Variable Management**: Variables are scoped hierarchically - child steps can access parent variables, but not vice versa. Each level of the hierarchy can have its own variable scope.

**State Management**: The context tracks completion status at each level of the hierarchy - which steps, sub-steps, and actions have completed, failed, or are in progress.

**Result Collection**: Results are stored hierarchically, allowing access to results from the current level, parent levels, or specific step paths.

**Context Navigation Methods**: The context provides methods to navigate the hierarchy (getCurrentStep(), getParentStep(), getChildSteps(), getSiblingSteps()) essential for control flow decisions.

## Plan Format

The executor works directly with llm-planner's format:

- **Plans** contain metadata (id, name, description) and an array of steps
- **Steps** can contain either sub-steps (for hierarchy) or actions (for execution)
- **Actions** specify a Legion tool name and parameters to pass to that tool
- **Dependencies** are declared at the step level using step IDs

The executor executes the hierarchical structure directly, as the hierarchy represents essential control flow like loops, repeats, fallbacks, and conditional logic that cannot be flattened without losing semantic meaning.

## Execution Flow

### Hierarchical Execution with Context Tracking

The executor maintains complete awareness of its position in the plan hierarchy:

1. **Context Maintenance**: Track current position (step path), parent steps, sibling steps, and execution stack
2. **Hierarchical Navigation**: Ability to traverse up to parent steps, down to children, or across to siblings
3. **Step Traversal**: For each step, determine if it has sub-steps or actions while maintaining context
4. **Sub-Step Processing**: When entering sub-steps, push context onto execution stack and update current position
5. **Action Processing**: When reaching leaf actions, execute them with full context awareness
6. **Tool Lookup**: Find the Legion tool that handles each action type (must have been loaded by ModuleLoader)
7. **Parameter Resolution**: Process action parameters with access to hierarchical context and variables
8. **Tool Execution**: Invoke the Legion tool with resolved parameters - this is the only way actions are executed
9. **Context Updates**: Update execution context as steps complete, fail, or require navigation
10. **Progress Reporting**: Emit events about step completion with hierarchical position information

### Error Handling

Basic error handling includes:

- **Retry Logic**: Failed steps can be retried a configurable number of times
- **Stop on Error**: By default, the first error stops execution
- **Error Context**: Errors include step ID and context for debugging

### Progress Events

The executor emits events during execution:

- `plan:start` - Plan execution begins
- `step:start` - Individual step begins
- `step:complete` - Step completes successfully  
- `step:error` - Step fails
- `plan:complete` - Plan execution ends
- `progress` - Periodic progress updates with completion percentage

## Implementation Approach

### MVP Scope

For the MVP, we implement:

1. **Basic sequential execution** - Process steps one at a time in dependency order
2. **Dynamic module loading** - Load Legion modules as needed for each plan
3. **Simple progress reporting** - Emit basic events during execution
4. **Error handling** - Basic retry logic and error collection
5. **Legion integration** - Proper module and tool interfaces

### What's Not Included in MVP

- Parallel execution of independent steps
- Advanced variable resolution between steps
- Checkpoint/resume functionality
- Complex retry policies
- Performance optimizations
- Security features

### Implementation Strategy

1. **Start with the module structure** - Create PlanExecutorModule and PlanExecutorTool with basic interfaces
2. **Implement core execution** - Build PlanExecutor to handle simple sequential execution
3. **Add module loading** - Implement ModuleLoader to dynamically load required tools
4. **Add progress reporting** - Emit basic events during execution
5. **Test with real plans** - Validate with actual llm-planner generated plans

## Usage Examples

### Basic Usage as Legion Module

```javascript
// Create module through ModuleFactory
const executorModule = moduleFactory.createModule(PlanExecutorModule);
const [executeTool] = executorModule.getTools();

// Execute a plan
const result = await executeTool.execute({
  plan: llmGeneratedPlan,
  options: { emitProgress: true }
});
```

### Standalone Usage

```javascript
// Direct instantiation
const executor = new PlanExecutor({ moduleFactory, resourceManager });
const result = await executor.executePlan(plan, options);
```

### Integration with Aiur

The executor can replace Aiur's current execution logic:

```javascript
// In Aiur's planning tools, use the executor instead of custom logic
const executorModule = this.moduleFactory.createModule(PlanExecutorModule);
const [executeTool] = executorModule.getTools();

// Execute llm-generated plans directly
const result = await executeTool.execute({ plan: llmPlan });
```

## Testing Strategy

### Unit Tests
- Test each component in isolation with mocked dependencies
- Test error conditions and edge cases
- Verify event emission

### Integration Tests  
- Test with real Legion modules
- Test various plan structures
- Verify end-to-end execution flow

### Test Infrastructure
- Mock tools for predictable behavior
- Sample plans for different scenarios
- Event capture for verification

## Debugging and Inspection Tools

The Plan Executor provides comprehensive debugging capabilities through multiple specialized tools that leverage the core execution engine's hierarchical context tracking and observable execution features.

### Tool Overview

The Plan Executor module exposes five distinct tools:

1. **`plan_execute`** - Standard execution tool for running complete plans
2. **`plan_execute_step`** - Step-by-step execution tool for debugging and manual progression  
3. **`plan_debug`** - Interactive debugging tool with breakpoint and inspection capabilities
4. **`plan_inspect`** - Plan analysis tool for structure validation and dependency visualization
5. **`plan_status`** - Execution state inspection tool for monitoring active executions

### plan_execute (Standard Execution)

The primary execution tool that runs plans from start to completion:

**Parameters:**
- `plan` (required) - The llm-planner Plan object to execute
- `options` (optional) - Execution options (emitProgress, stopOnError, timeout, retries)

**Behavior:**
- Executes the entire plan hierarchically according to dependencies
- Emits progress events during execution
- Returns complete execution results including statistics and any errors

### plan_execute_step (Step-by-Step Execution)

Enables manual progression through plan execution for debugging:

**Parameters:**
- `plan` (required) - The plan to execute step-by-step
- `sessionId` (optional) - Session identifier for resuming existing executions
- `action` (required) - Action to take: 'start', 'next', 'pause', 'resume', 'abort'
- `options` (optional) - Standard execution options

**Behavior:**
- Maintains execution sessions that can be paused and resumed
- Executes one step at a time, waiting for manual progression
- Provides detailed step information and context at each pause point
- Allows inspection of variables and state between steps

### plan_debug (Interactive Debugging)

Advanced debugging tool with breakpoint and inspection capabilities:

**Parameters:**
- `plan` (required) - The plan to debug
- `breakpoints` (optional) - Array of step IDs where execution should pause
- `inspectVariables` (optional) - Boolean flag to include variable state in responses
- `traceExecution` (optional) - Boolean flag to include detailed execution traces

**Behavior:**
- Automatically pauses at specified breakpoints
- Provides comprehensive context inspection at pause points
- Includes variable scoping information and execution stack traces
- Allows conditional breakpoints based on step outcomes or variable values

### plan_inspect (Plan Analysis)

Static analysis tool for plan structure and dependency validation:

**Parameters:**
- `plan` (required) - The plan to inspect
- `analyzeDepth` (optional) - Depth of hierarchical analysis ('shallow', 'deep', 'complete')
- `validateTools` (optional) - Boolean flag to validate tool availability
- `showDependencies` (optional) - Boolean flag to include dependency graph

**Behavior:**
- Validates plan structure and identifies potential issues
- Analyzes dependency chains and detects circular dependencies
- Reports on required tools and their availability
- Provides execution time estimates and complexity metrics
- Visualizes hierarchical structure and control flow

### plan_status (Execution State Inspection)

Real-time inspection tool for active plan executions:

**Parameters:**
- `sessionId` (optional) - Specific session to inspect, or 'all' for all active sessions
- `includeContext` (optional) - Boolean flag to include execution context details
- `includeResults` (optional) - Boolean flag to include step results in response

**Behavior:**
- Reports on active execution sessions and their current state
- Provides real-time progress information and step completion status  
- Includes execution context and variable state for debugging
- Shows execution stack and hierarchical position information

### Integration with Core Execution Engine

All debugging tools leverage the same PlanExecutor core engine, ensuring consistency:

- **Hierarchical Context Tracking** - All tools have access to execution position and context stack
- **Variable Scoping** - Step-by-step and debug tools can inspect hierarchical variable scopes
- **Event Emission** - All executions emit the same progress events for monitoring
- **Error Handling** - Consistent error handling and retry logic across all execution modes

## Success Criteria

The MVP is successful if it can:

1. Execute simple llm-planner generated plans
2. Dynamically load required Legion modules  
3. Emit progress events during execution
4. Handle basic errors with retry logic
5. Integrate cleanly as a Legion module
6. Replace Aiur's current execution logic
7. Provide comprehensive debugging capabilities through specialized tools
8. Enable step-by-step execution and inspection for development workflows

## Conclusion

The Plan Executor MVP provides a clean separation between plan generation and execution while following Legion's patterns. It enables AI-generated plans to drive real actions through Legion's tool ecosystem in a standardized, reusable way.

The design is intentionally simple for the MVP while providing a foundation that can be extended with advanced features as needs evolve.