/**
 * Real development tools for the ClassGeneratorWorkflow
 * These tools actually generate code, write files, run tests, and fix issues
 */

import fs from 'fs/promises';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export class RealDevTools {
  constructor(workingDirectory = './generated') {
    this.workingDir = workingDirectory;
    this.directoriesCreated = false;
  }

  async ensureWorkingDirectory() {
    if (this.directoriesCreated) return;
    
    try {
      await fs.mkdir(this.workingDir, { recursive: true });
      await fs.mkdir(path.join(this.workingDir, 'src'), { recursive: true });
      await fs.mkdir(path.join(this.workingDir, 'tests'), { recursive: true });
      this.directoriesCreated = true;
    } catch (error) {
      // Directory might already exist, but mark as created anyway
      this.directoriesCreated = true;
    }
  }

  /**
   * Create a real class generator tool
   * Uses actual code generation with proper JavaScript syntax
   */
  createClassGenerator() {
    const self = this;
    return {
      name: 'classGenerator',
      async execute(params) {
        const { className, description, methods = [] } = params;
        
        if (!className) {
          return { 
            success: false, 
            data: { error: 'className is required' } 
          };
        }

        // Generate real JavaScript class code
        const methodImplementations = methods.map(method => {
          return self.generateMethodImplementation(method);
        }).join('\n\n');

        const classCode = `/**
 * ${description || `Class ${className}`}
 * Generated by ClassGeneratorWorkflow
 */
class ${className} {
  constructor() {
    this.data = new Map();
    this.initialized = true;
  }

${methodImplementations}
}

export default ${className};`;

        // Ensure directory structure exists before writing
        await self.ensureWorkingDirectory();
        
        // Write to actual file
        const filePath = path.join(self.workingDir, 'src', `${className}.js`);
        try {
          await fs.writeFile(filePath, classCode, 'utf-8');
          
          return {
            success: true,
            data: {
              code: classCode,
              className,
              filePath,
              methods,
              linesOfCode: classCode.split('\n').length,
              timestamp: Date.now()
            }
          };
        } catch (error) {
          return {
            success: false,
            data: { error: `Failed to write file: ${error.message}` }
          };
        }
      },
      getMetadata() {
        return {
          name: 'classGenerator',
          description: 'Generates real JavaScript class files',
          input: {
            className: { type: 'string', required: true },
            description: { type: 'string', required: false },
            methods: { type: 'array', required: true }
          },
          output: {
            code: { type: 'string' },
            filePath: { type: 'string' },
            linesOfCode: { type: 'number' }
          }
        };
      }
    };
  }

  /**
   * Create a real test generator tool
   * Generates actual Jest test files
   */
  createTestGenerator() {
    const self = this;
    return {
      name: 'testGenerator',
      async execute(params) {
        const { className, methods = [] } = params;
        
        if (!className) {
          return { 
            success: false, 
            data: { error: 'className is required' } 
          };
        }

        // Generate real Jest test code
        const testCases = methods.map(method => {
          return self.generateTestCase(className, method);
        }).join('\n\n');

        const testCode = `import ${className} from '../src/${className}.js';

describe('${className}', () => {
  let instance;

  beforeEach(() => {
    instance = new ${className}();
  });

  test('should create instance correctly', () => {
    expect(instance).toBeDefined();
    expect(instance.initialized).toBe(true);
    expect(instance.data).toBeInstanceOf(Map);
  });

${testCases}
});`;

        // Ensure directory structure exists before writing
        await self.ensureWorkingDirectory();
        
        // Write actual test file
        const testPath = path.join(self.workingDir, 'tests', `${className}.test.js`);
        try {
          await fs.writeFile(testPath, testCode, 'utf-8');
          
          return {
            success: true,
            data: {
              testCode,
              testPath,
              className,
              testCount: methods.length + 1,
              timestamp: Date.now()
            }
          };
        } catch (error) {
          return {
            success: false,
            data: { error: `Failed to write test file: ${error.message}` }
          };
        }
      },
      getMetadata() {
        return {
          name: 'testGenerator',
          description: 'Generates real Jest test files',
          input: {
            className: { type: 'string', required: true },
            methods: { type: 'array', required: false }
          },
          output: {
            testCode: { type: 'string' },
            testPath: { type: 'string' },
            testCount: { type: 'number' }
          }
        };
      }
    };
  }

  /**
   * Create a real test runner tool
   * Actually executes Jest tests
   */
  createTestRunner() {
    const self = this;
    return {
      name: 'testRunner',
      async execute(params) {
        const { className } = params;
        
        if (!className) {
          return { 
            success: false, 
            data: { error: 'className is required to run tests' } 
          };
        }

        // Create package.json if it doesn't exist
        await self.ensurePackageJson();

        try {
          // Run Jest for the specific test file
          const testFile = `tests/${className}.test.js`;
          const command = `cd "${self.workingDir}" && npm test -- --testPathPattern="${testFile}" --json`;
          
          const { stdout, stderr } = await execAsync(command, { 
            cwd: self.workingDir,
            timeout: 30000 // 30 second timeout
          });

          // Parse Jest JSON output
          let testResults;
          try {
            testResults = JSON.parse(stdout);
          } catch {
            // Fallback parsing if JSON is malformed
            testResults = self.parseTestOutput(stdout + stderr);
          }

          const success = testResults.success || (testResults.numFailedTests === 0);
          
          return {
            success,
            data: {
              totalTests: testResults.numTotalTests || 0,
              passed: testResults.numPassedTests || 0,
              failed: testResults.numFailedTests || 0,
              failures: testResults.testResults?.[0]?.assertionResults?.filter(r => r.status === 'failed') || [],
              coverage: testResults.coverageMap ? self.calculateCoverage(testResults.coverageMap) : null,
              executionTime: testResults.testResults?.[0]?.endTime - testResults.testResults?.[0]?.startTime || 0,
              rawOutput: stdout,
              timestamp: Date.now()
            }
          };
        } catch (error) {
          return {
            success: false,
            data: {
              error: `Test execution failed: ${error.message}`,
              stderr: error.stderr,
              totalTests: 0,
              passed: 0,
              failed: 1,
              failures: [{ message: error.message }]
            }
          };
        }
      },
      getMetadata() {
        return {
          name: 'testRunner',
          description: 'Runs real Jest tests',
          input: {
            className: { type: 'string', required: true }
          },
          output: {
            totalTests: { type: 'number' },
            passed: { type: 'number' },
            failed: { type: 'number' },
            failures: { type: 'array' }
          }
        };
      }
    };
  }

  /**
   * Create a real code analyzer and fixer tool
   * Analyzes test failures and attempts to fix code
   */
  createCodeFixer() {
    const self = this;
    return {
      name: 'codeFixer',
      async execute(params) {
        const { className, testResults } = params;
        
        if (!className || !testResults) {
          return { 
            success: false, 
            data: { error: 'className and testResults are required' } 
          };
        }

        const fixes = [];
        let fixedCode = null;

        if (testResults.failures && testResults.failures.length > 0) {
          // Read the current class file
          const classPath = path.join(self.workingDir, 'src', `${className}.js`);
          try {
            const currentCode = await fs.readFile(classPath, 'utf-8');
            fixedCode = currentCode;

            // Analyze each failure and attempt fixes
            for (const failure of testResults.failures) {
              const fix = await self.analyzeAndFix(failure, fixedCode, className);
              if (fix.applied) {
                fixes.push(fix);
                fixedCode = fix.newCode;
              }
            }

            // Write the fixed code back
            if (fixes.length > 0) {
              await fs.writeFile(classPath, fixedCode, 'utf-8');
            }

            return {
              success: fixes.length > 0,
              data: {
                fixes,
                fixedCode,
                fixCount: fixes.length,
                originalIssues: testResults.failures.length,
                timestamp: Date.now()
              }
            };
          } catch (error) {
            return {
              success: false,
              data: { error: `Failed to fix code: ${error.message}` }
            };
          }
        } else {
          return {
            success: true,
            data: {
              message: 'No failures to fix',
              fixCount: 0
            }
          };
        }
      },
      getMetadata() {
        return {
          name: 'codeFixer',
          description: 'Analyzes and fixes code based on test failures',
          input: {
            className: { type: 'string', required: true },
            testResults: { type: 'object', required: true }
          },
          output: {
            fixes: { type: 'array' },
            fixCount: { type: 'number' }
          }
        };
      }
    };
  }

  // Helper methods for code generation
  generateMethodImplementation(methodName) {
    // Analyze method name to generate appropriate implementation
    if (methodName.toLowerCase().includes('add') || methodName.toLowerCase().includes('create')) {
      return `  ${methodName}(data) {
    if (!data) {
      throw new Error('Data is required');
    }
    const id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
    const item = { id, ...data, createdAt: new Date().toISOString() };
    this.data.set(id, item);
    return item;
  }`;
    }
    
    if (methodName.toLowerCase().includes('get') || methodName.toLowerCase().includes('find')) {
      return `  ${methodName}(id) {
    if (!id) {
      throw new Error('ID is required');
    }
    const item = this.data.get(id);
    if (!item) {
      throw new Error('Item not found');
    }
    return item;
  }`;
    }
    
    if (methodName.toLowerCase().includes('update')) {
      return `  ${methodName}(id, updates) {
    if (!id) {
      throw new Error('ID is required');
    }
    if (!updates) {
      throw new Error('Updates are required');
    }
    const existing = this.data.get(id);
    if (!existing) {
      throw new Error('Item not found');
    }
    const updated = { ...existing, ...updates, updatedAt: new Date().toISOString() };
    this.data.set(id, updated);
    return updated;
  }`;
    }
    
    if (methodName.toLowerCase().includes('delete') || methodName.toLowerCase().includes('remove')) {
      return `  ${methodName}(id) {
    if (!id) {
      throw new Error('ID is required');
    }
    const item = this.data.get(id);
    if (!item) {
      throw new Error('Item not found');
    }
    this.data.delete(id);
    return item;
  }`;
    }
    
    if (methodName.toLowerCase().includes('list') || methodName.toLowerCase().includes('getall')) {
      return `  ${methodName}() {
    return Array.from(this.data.values());
  }`;
    }

    // Default generic method
    return `  ${methodName}(param) {
    // Implementation for ${methodName}
    console.log('${methodName} called with:', param);
    return { success: true, method: '${methodName}', param };
  }`;
  }

  generateTestCase(className, methodName) {
    if (methodName.toLowerCase().includes('add') || methodName.toLowerCase().includes('create')) {
      return `  test('should ${methodName} correctly', () => {
    const testData = { name: 'Test Item', value: 42 };
    const result = instance.${methodName}(testData);
    
    expect(result).toBeDefined();
    expect(result.id).toBeDefined();
    expect(result.name).toBe('Test Item');
    expect(result.value).toBe(42);
    expect(result.createdAt).toBeDefined();
  });

  test('should throw error when ${methodName} called without data', () => {
    expect(() => instance.${methodName}()).toThrow('Data is required');
  });`;
    }
    
    if (methodName.toLowerCase().includes('get') || methodName.toLowerCase().includes('find')) {
      return `  test('should ${methodName} correctly', () => {
    // First add an item
    const added = instance.addItem({ name: 'Test' });
    const result = instance.${methodName}(added.id);
    
    expect(result).toBeDefined();
    expect(result.id).toBe(added.id);
    expect(result.name).toBe('Test');
  });

  test('should throw error when ${methodName} called with invalid ID', () => {
    expect(() => instance.${methodName}('invalid')).toThrow('Item not found');
  });`;
    }

    // Default test case
    return `  test('should ${methodName} correctly', () => {
    const result = instance.${methodName}('test-param');
    expect(result).toBeDefined();
    expect(result.success).toBe(true);
    expect(result.method).toBe('${methodName}');
  });`;
  }

  async ensurePackageJson() {
    const packagePath = path.join(this.workingDir, 'package.json');
    try {
      await fs.access(packagePath);
    } catch {
      // package.json doesn't exist, create it
      const packageJson = {
        name: 'generated-classes-test',
        version: '1.0.0',
        type: 'module',
        scripts: {
          test: 'jest --experimental-vm-modules'
        },
        jest: {
          preset: 'es-modules',
          testEnvironment: 'node',
          transform: {},
          extensionsToTreatAsEsm: ['.js']
        },
        devDependencies: {
          jest: '^29.0.0'
        }
      };
      await fs.writeFile(packagePath, JSON.stringify(packageJson, null, 2));
    }
  }

  parseTestOutput(output) {
    // Fallback parser for when JSON parsing fails
    const lines = output.split('\n');
    let totalTests = 0;
    let passed = 0;
    let failed = 0;
    
    for (const line of lines) {
      if (line.includes('Tests:')) {
        const match = line.match(/(\d+) passed/);
        if (match) passed = parseInt(match[1]);
        
        const failMatch = line.match(/(\d+) failed/);
        if (failMatch) failed = parseInt(failMatch[1]);
        
        totalTests = passed + failed;
      }
    }
    
    return {
      success: failed === 0,
      numTotalTests: totalTests,
      numPassedTests: passed,
      numFailedTests: failed,
      testResults: [{ assertionResults: [] }]
    };
  }

  calculateCoverage(coverageMap) {
    // Simple coverage calculation
    let totalLines = 0;
    let coveredLines = 0;
    
    for (const [file, coverage] of Object.entries(coverageMap)) {
      if (coverage.s) { // statement coverage
        const statements = Object.values(coverage.s);
        totalLines += statements.length;
        coveredLines += statements.filter(count => count > 0).length;
      }
    }
    
    return totalLines > 0 ? Math.floor((coveredLines / totalLines) * 100) : 0;
  }

  async analyzeAndFix(failure, code, className) {
    // Simple pattern-based fixing
    let newCode = code;
    let applied = false;
    
    const failureMessage = failure.message || failure.toString();
    
    // Fix common patterns
    if (failureMessage.includes('not defined') || failureMessage.includes('is not a function')) {
      const methodMatch = failureMessage.match(/(\w+) is not a function/);
      if (methodMatch) {
        const missingMethod = methodMatch[1];
        // Add a basic implementation for the missing method
        const methodImpl = `  ${missingMethod}(param) {
    return { success: true, method: '${missingMethod}', param };
  }`;
        
        // Insert before the closing brace of the class
        newCode = newCode.replace(/}\s*export default/, `\n${methodImpl}\n}\n\nexport default`);
        applied = true;
      }
    }
    
    if (failureMessage.includes('Data is required') && code.includes('throw new Error')) {
      // Maybe need to add null checks - this is a placeholder for more sophisticated fixing
    }
    
    return {
      applied,
      newCode,
      issue: failureMessage,
      fix: applied ? 'Added missing method implementation' : 'No fix applied'
    };
  }

  /**
   * Create a success validator tool
   * Checks if tests passed and determines if workflow should continue or retry
   */
  createSuccessValidator() {
    return {
      name: 'successValidator',
      async execute(params) {
        const { testResults } = params;
        
        if (!testResults) {
          return { 
            success: false, 
            data: { error: 'testResults are required' } 
          };
        }

        const allPassed = testResults.failed === 0 && testResults.passed > 0;

        if (allPassed) {
          return {
            success: true,
            data: {
              message: 'All tests passed successfully!',
              testsPassed: testResults.passed,
              totalTests: testResults.totalTests,
              coverage: testResults.coverage,
              executionTime: testResults.executionTime
            }
          };
        } else {
          return {
            success: false,
            data: {
              error: 'Tests failed - needs fixing',
              failureCount: testResults.failed,
              failures: testResults.failures,
              testsPassed: testResults.passed,
              totalTests: testResults.totalTests
            }
          };
        }
      },
      getMetadata() {
        return {
          name: 'successValidator',
          description: 'Validates test results for workflow decisions',
          input: {
            testResults: { type: 'object', required: true }
          },
          output: {
            message: { type: 'string' },
            testsPassed: { type: 'number' }
          }
        };
      }
    };
  }
}